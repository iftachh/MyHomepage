  <!DOCTYPE html>
<html><head><title>Iftach Haitner's Home Page</title>
<script type="text/javascript" src="jquery.js"></script>
<style>
BODY { font-family :  verdana, arial, helvetica, sans-serif; BACKGROUND-COLOR: #eee ; color : #333  ; }
.shadow1 {box-shadow: 5px 5px 20px #888888; line-height : 150% ;}
.shadow2 {box-shadow: 5px 5px 20px #888888; border-radius : 8px }
 #wrapall {  max-width : 1100px ; margin:auto}
  #wrapper {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; margin-left : 30px ; padding-bottom : 30px }
strong, b {    color : #636363 }
   .abslide { color : #3956CC  ; cursor : pointer ;  }
 .abslide:hover {  text-decoration: underline;   }
 #wrapper div.box {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; margin-bottom : 20px}
  #wrapper div.box p {    margin : 0px ; }
    #topwrap {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; ; margin-left : 30px ;  padding-bottom : 30px }
   #topwrap div.top {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; line-height : 150% ;}
      #topwrap div.top a:hover {      text-decoration : underline     }
    #pub1 li {      line-height : 150% ; }
     a {      color : #3956CC  ; text-decoration : none   }

  .boxtop { color : #3956CC  ; cursor : pointer ; font-size :150%  }
 .boxtop:hover {  text-decoration: underline;   }
    #topwrap  ul {     list-style: none   }
      h1 {      font-size : 150% ; color :  #636363   }
    h2 {     font-size : 120%  }
 .update {  position : relative;top : 2px ; left : 10px ;border : 1px solid #91BF46 ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; padding-right : 0px; padding-left: 0px }
   .update1 {  position : relative;top : 2px ; left : 10px ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; }

 .blu1 {color: #000080;}
.blu2 {color: #003FFF; }



</style>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="Iftach Haitner, Iftach, Haitner, יפתח היטנר, הייטנר, יפתח, Home Page, Cryptography">
<meta content="Iftach Haitner's Home Page" name="description">
<script language="JavaScript" type="text/JavaScript">


 $(document).ready(function(){
     $('.abslide').click(function(){$(this).closest('li').find(".box").slideToggle("slow","swing")});

     $(".boxtop").click(topslide);
   function topslide(){
   kukuclass="." +this.id  ;$(".top").hide("slow") ;
   $("#info").closest('div').find(kukuclass ).show("slow","swing")    ;    }
           });

</script>

</head>
<body>
<div id=wrapall>
  <div id=topwrap style="padding-left : 40px">
<h1>Iftach Haitner - <span style="font-size : 125%"> יפתח הייטנר</span> </h1>
<img src="Face.jpg" width="192" height="233" alt="Iftach Haitner " style="display : block" class=shadow2>
<p style="font-size : 110%"> I am a faculty member at the <a href="http://www.cs.tau.ac.il">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.
I am a member at the <a href="http://www.icore-algo.org.il/">Israeli
Center of Research Excellence in Algorithms (ICORE)</a> and the <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security</a>.<br><br>
My main research interests are Cryptography and Computational
Complexity.<br></p>


<span class=boxtop id=info>[Info]</span>
<span class=boxtop id=bio>[Short Bio]</span>
<span class=boxtop id=pro>[Professional Activity]</span>
<span class=boxtop id=teach>[Teaching]</span>  
<span class=boxtop id=edu>[School Activity]</span>

<div class="info top">
<h2>Contact Information</h2>
Tel Aviv university, Schreiber Building, Office 20<br>
Phone:+972-3-6407996<br>
Fax: +972-3-6409373<br>
Email: [firstname] [dot] [lastname] [at] cs.tau.ac.il<br>
Mail: Iftach Haitner, Tel Aviv university, P.O.B. 39040, Ramat Aviv, Tel Aviv 69978, Israel <br>
 </div>

<div class="bio top">
<h2>Short Biography </h2>
I am a member of the <a href="http://www.cs.tau.ac.il">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.<br>
I am a member at the <a href="http://www.icore-algo.org.il/">Israeli
Center of Research Excellence in Algorithms (ICORE)</a> and the <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security.</a><br>
Until July 2010, I was a postdoctoral researcher at <a href="http://research.microsoft.com/en-us/labs/newengland/">Microsoft
Research New England</a>. Prior to the time at Microsoft
Research, I did a six months postdoc at <a href="http://www.cs.haifa.ac.il/"><font>Department of
Computer Science, University of Haifa</font></a>, hosted by
<a href="http://cs.haifa.ac.il/%7Eronen/"> Ronen
shaltiel</a>.
I received my PhD in 2008 from the <a href="http://www.wisdom.weizmann.ac.il/">Faculty of
Mathematics and Computer Science, Weizmann Institute of Science,</a>  under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/">Omer
Reingold</a> I got my Master's degree also
from the Weizmann Institute, under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Eoded/">Oded
Goldreich</a>, and did my undergraduate studies (Mathematics and
Computer Science) at <a href="http://www.tau.ac.il/">Tel-Aviv
university</a><br><br>

<b>Grants</b><br>
<ul>
<li>[2011-2015] Israel  Science Foundation(ISF) -- Individual research grant. </li>
<li>[2011-2015] Israel Science Foundation (ISF) -- Equipment for new faculty. </li>
<li>[2011-2015] Israel Science Foundation(ISF) -- Israeli Center of Research Excellence in Algorithms. </li>
<li>[2011-2015] US-Israel Binational Science Foundation
(BSF), with Salil Vadhan.</li>
</ul>
<br>
<b>wards and Fellowships</b><br>
<ul>
<li>[2011] One of the three winning papers of the 2011 SIAM Outstanding  Paper Prizes.<br>
The prizes are given for outstanding papers published in SIAM journals during the three years prior to the year of the award. </li>
<li> [2008] The John F. Kennedy Prize (awarded by the  Weizmann Institute) </li>
<li> [2008] Intel (Israel) award for outstanding Ph.D. students</li>
<li> [2008] Rothschild Fellowship for Post-Doctoral  Research (declined)</li>
<li> [2007] Otto Schwartz prize for excellent studies, PhD</li>
<li> [2007] Dean's List of Honour at the Weizmann Institute of Science</li>
<li> [2006] Best paper CRYPTO 2006</li>
<li> [2006] Best paper award ICALP 2006 track C</li>
</ul>
</div>



 <div class="pro top">
<h2>Professional Activity</h2>

<b>Program Committees</b><br>
<ul>
 <li> <a href="http://www.iacr.org/workshops/tcc2014/">Theory of  Cryptography Conference (TCC) 2014</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2013/">CRYPTO 2013</a></li>
<li> <a href="http://computationalcomplexity.org/Archive/2013/cfp.html">Conference on Computational Complexity (CCC) 2013</a></li>
<li> <a href="http://www.iacr.org/workshops/tcc2012/">Theory  of Cryptography Conference (TCC) 2012</a></li>
<li> <a href="http://cist.korea.ac.kr/%7Easiacrypt2011/">Asiacrypt 2011</a> </li>
<li> <a href="http://ct-rsa2011.di.uoa.gr/CT-RSA_2011/Welcome___CT-RSA_2011.html">CT-RSA  2011</a></li>
<li> <a href="http://www.crypto.ethz.ch/tcc2010/">Theory  of Cryptography Conference (TCC) 2010</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2009/">CRYPTO  2009</a></li>
</ul>
<b>Seminars   and Workshops </b>
<UL>
 <li>Co-organizer  of the <a href="http://www.cs.tau.ac.il/cseminar/">Greater Tel Aviv Area Cryptography Seminar (GTACS)</a></li>
<li>Co-organizer of the <a href="http://intractability2013.workshop.org.il/">Modeling  Intractability workshop 2013</a></li>
</UL>
<b>Teaching</b> (outside of TelAviv university)
<ul>
<li><a href="http://crypto.biu.ac.il/winterschool2014/">4th  Bar-Ilan Winter School on Cryptography</a></li>
<li> <a href="http://blackboxsummerschool.wordpress.com/">School on   Black-Box Impossibility Results  </a></li>
</ul>
</div>

 <div class="teach top">
<h2> Teaching  </h2>
<ul>
  <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/AvgHardness/Spring15.html"> Average-Case Hardness (student seminar)&nbsp; (Spring 15)</a></li>
  <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Info/Fall14/index.html"> Applications of Information Theory&nbsp; (Fall 14)</a></li>
  <li><a href="http://tau-cm2014.wikidot.com/">Computational Model (Spring 14)</a></li>
  <li><a  href="Courses/FOC/Spring14/index.html" >Foundation  of Cryptography (Spring 14)</a></li>
</ul></div>

<div class="edu top">
<h2>School Activity</h2>
<ul>
<li><a href="http://www.cs.tau.ac.il/MSCX_program/mscx.htm">Excellence Program for Master Studies</a></li>
 </ul>
</div>



</div> <!--topwrap-->
<!-----------------publications---------------------------------------->


 <div id=wrapper >
 <h1 style="margin-left : 30px ; margin-top : 0px">Publications   <span style="font-size :12px ; font-weight : 400">(in Reverse Chronological Order)</span></h1>

<ul id=pub1>


<li>
<p>
<a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay Berman</a> and Iftach Haitner and  <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>Coin Flipping of Any Constant Bias Implies One-Way Functions </strong> <br>
<span class=abslide>[Abstract]</span>[<a href="papers/TightCF/TightCoinFlipping_full.ppsx">slides</a>]<br>
STOC 2014 <a name="HHRSJoint0"></a> <a href="papers/TightCF/TightCoingFlipping_CR.pdf">[PDF]</a>
</p>


<div class="box"  >
<p>We show that the existence of a coin-flipping protocol safe against any non-trivial constant bias (e.g., .<span class=blu1>499</span>), implies the
existence of one way functions. This improves upon a recent result of <span class=blu2>Haitner and Omri</span> [FOCS ’11],
who proved this implication for protocols with bias √ 2−<sup>1</sup>⁄<sub>2</sub>&nbsp;
&nbsp;~.207.
Unlike the result of
Haitner and Omri , our result holds also for <em>
weak</em> coin-flipping protocols.</p>
</div>
 </li>



<li>

Iftach Haitner and Eliad Tsfadia <br>
<strong>An Almost-Optimally Fair Three-Party Coin-Flipping Protocol</strong><br>
 [<span class=abslide>Abstract</span>] [<a href="papers/3PartyCF/3Party-full.ppsx">slides</a>] <br>
STOC 2014 <a href="papers/3PartyCF/QuasiOptimalCF_CR.pdf">[PDF]</a><br>
Draft of dull version <a href="papers/3PartyCF/QuasiOptimalCF.pdf">[PDF]</a> <img src="up7.png" class=update1>



<div class="box"  >
<p>In a multiparty, fair coin-flipping protocol, the
parties output a common (close to) unbiased bit, even when some
corrupted parties try to bias the output. Cleve
[STOC 1986] has shown that in the case of dishonest
majority (i.e., at least half of the parties can be corrupted), the
corrupted parties can bias the honest parties common output bit
by&nbsp; Ω(1/m), in any m-round, coin-flipping
protocol. For more than two decades, however, the best known
coin-flipping protocols had bias Θ(t/√
m) against dishonest majority, where t is the number of
corrupted parties. This was changed by a recent breakthrough result of Moran et al. [TCC 2009],
who constructed an m-round,
two-party coin-flipping protocol with optimal bias Θ(1/m). Where in a
subsequent work, Beimel et al.
[Crypto 2010] extended this result for the multiparty
case, in which less than  <sup>2</sup>⁄<sub>3</sub> of
the parties can be corrupted. More specifically, for any t &lt; <sup>2</sup>⁄<sub>3</sub>
· k, they
presented an m-round, k-party
protocol, with bias Θ( 2<sup>2t−k</sup>/m)
against (up to) t
corrupted parties.&nbsp; Still for the case  <sup>2</sup>⁄<sub>3</sub>
(or more) corrupted parties, the best known protocol had bias Θ(t/√ m). In particular,
this was the state of affairs for the natural three-party case (against
two corrupted parties).<br>
<br>
We make a step towards eliminating the above gap, presenting an m-round, three-party,
coin-flipping protocol, with bias&nbsp;
O(log 3 m)/m.
Our approach (which we also apply for the two-party case), does not
follow the “threshold round” paradigm used in the work of Moran et al. and Beimel et al.,
but rather is a takeoff of the majority protocol of Cleve (used to obtain the Θ(t/√ m )-bias protocol,
mentioned above).</p>
</div>
</li>







<li>
<p>
Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>
 and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<strong>Finding Collisions in Interactive Protocols — Tight Lower Bounds on the Round Complexity and Communication Complexityof Statistically Hiding Commitments </strong>
<br>
[<span class=abslide>Abstract</span>]<br>
SIAM Journal of Computing 2015, to appear<br>

Draft of full version <a href="papers/FindingCollisions/FindingCollisions_Joint.pdf"> [PDF]</a>  <img src="new8.png" class=update1>
</p>


<div class="box" >
 We study the round complexity and communication
complexity of
various cryptographic protocols. We give tight lower bounds on the
round complexity and communication complexity of any fully black-box
reduction of a statistically hiding commitment scheme from one-way
permutations, and from trapdoor permutations. As a corollary, we derive
similar tight lower bounds for several other cryptographic protocols,
such as single-server private information retrieval, interactive
hashing, and oblivious transfer that guarantees statistical security
for one of the parties. Our techniques extend the collision-finding
oracle due to Simon (EUROCRYPT
98) to the setting of interactive protocols, and the
reconstruction paradigm of Gennaro
and Trevisan (FOCS 00).

</div>
 </li>



<li>
<p><a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay
Berman</a> and Iftach Haitner and&nbsp;<a href="https://sites.google.com/site/ilankomhomepage/"> Ilan
Komargodski</a> and&nbsp; <a href="http://www.wisdom.weizmann.ac.il/%7Enaor/">Moni Naor</a><br>
<strong>Hardness Preserving Reductions via Cuckoo
Hashing </strong><br> [<span class=abslide>Abstract</span>] &nbsp<br>
TCC 2013   <a href="papers/Cuckoo/Cuckoo_TCC.pdf">[PDF]</a><br>
 Draft
of full version
[<a href="papers/Cuckoo/Cuckoo%20.pdf">PDF</a>]</p>
<div class="box"  >
A common method for increasing the usability and uplifting the security
of pseudorandom function families (PRFs) is to “hash” the inputs into a
smaller domain before applying the PRF.<br>
This approach, known as “Levin’s trick”, is used to achieve “PRF domain
extension” (using a short, e.g., fixed, input length PRF to get a
variable-length PRF), and more recently to transform<br>
non-adaptive PRFs to adaptive ones. Such reductions, however, are
vulnerable to a “birthday attack”: after √|U|
queries to the resulting PRF, where U
being the hash function range, a<br>
collision (i.e., two distinct inputs have the same hash value) happens
with high probability. As a consequence, the resulting PRF is insecure
against an attacker making this number of queries.<br>
In this work we show how to go beyond the birthday attack barrier, by
replacing the above simple hashing approach with a variant of <strong>cuckoo
hashing</strong> — a hashing paradigm typically used<br>
for resolving hash collisions in a table, by using two hash functions
and two tables and cleverly assigning each element into one of the two
tables. We use this approach to obtain:<br>
(i) A domain extension method that requires <strong>just two
calls</strong> to the original PRF, can withstand as many queries
as the original domain size and has a distinguishing probability that
is exponentially small in the non cryptographic work. <br>
(ii) A <strong>security-preserving</strong> reduction from
non-adaptive to adaptive PRFs.
</div>
</li>

<li>
<p>   Iftach Haitner and
<a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a>&nbsp; and <a href="http://u.cs.biu.ac.il/%7Ezarosih/">Hila Zarosim</a>&nbsp;
<br>
<strong>Limits on the
Usefulness of Random Oracles</strong> [<span class=abslide>Abstract</span>] <br>
 TCC 2013 [<a href="papers/PowerofRO1/PowerOfRO_TCC.pdf">PDF</a>]<br>
Draft of full version  <a href="papers/PowerofRO1/PowerOfRO.pdf">[PDF]</a></p>
<div class="box"  >
 In
the <strong>random oracle</strong> model, parties are
given oracle access to a random function (i.e., a uniformly chosen
function from the set of all functions), and are assumed to have
unbounded computational power (though they can only make a bounded
number of oracle queries). This model provides powerful properties that
allow proving the security of many protocols, even such that cannot be
proved secure in the standard model (under any hardness assumption).
The random oracle model is also used for showing that a given
cryptographic primitive cannot be used in a black-box way to construct
another primitive; in their seminal work, Impagliazzo
and Rudich [STOC ’89] showed that no key-agreement
protocol exists in the random oracle model, yielding that key-agreement
cannot be black-box reduced to one-way functions. Their work has a long
line of follow-up works (Simon
[EC ’98], Gertner
et al. [STOC ’00] and
Gennaro et al. [SICOMP ’05], to name a few), showing that
given oracle access to a certain type of function family (e.g., the
family that “implements” public-key encryption) is not sufficient for
building a given cryptographic primitive (e.g., oblivious transfer).
Yet, the following question remained open:
<br>
<br>
<em>What is the exact power of the random oracle model?
<br>
</em><br>
We make progress towards answering the above question, showing that,
essentially, any no private input, semi-honest two-party functionality
that can be securely implemented in the random oracle model, can be
securely implemented information theoretically (where parties are
assumed to be all powerful, and no oracle is given). We further
generalize the above result to function families that provide some
natural combinatorial property. <br>
Our result immediately yields that that the only no-input
functionalities that can be securely realized in the random oracle
model (in the sense of secure function evaluation), are the trivial
ones (ones that can be securely realized information theoretically). In
addition, we use the recent information theoretic impossibility result
of McGregor et al. [FOCS ’10],
to show the existence of functionalities (e.g., inner product) that
cannot be computed both accurately and in a differentially private
manner in the random oracle model; yielding that protocols for
computing these functionalities cannot be black-box reduced to the
existence of one-way functions. 
</div>
</li>

<li>
<p class="auto-style7">   <a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay
Berman</a> and Iftach Haitner  <br>
<strong>From Non-Adaptive to Adaptive Pseudorandom
Functions</strong>&nbsp;[<span class=abslide>Abstract</span>]<br>
  Journal of
Cryptology 2013   <a  href="http://link.springer.com/article/10.1007/s00145-013-9169-2">[link]</a><b><i>
</i></b><br>
TCC 2012   <a href="papers/AdaptivePRF/AdaptivePRF_TCC.pdf">[PDF]</a><br>
 Draft of full version <a href="papers/AdaptivePRF/AdaptivePRF.pdf">[PDF]</a></p>

<div class="box"  >
 Unlike
the standard notion of pseudorandom functions (PRF), a <strong>
non-adaptive</strong> PRF is only required to be
indistinguishable from a random function in the eyes of a <strong>non-adaptive</strong>
distinguisher (i.e., one that prepares its oracle calls in advance). A
recent line of research has studied the possibility of a <strong>direct</strong>
construction of adaptive PRFs from non-adaptive ones, where direct
means that the constructed adaptive PRF uses only few (ideally,
constant number of) calls to the underlying non-adaptive PRF.
Unfortunately, this study has only yielded negative results, showing
that ``natural" such constructions are unlikely to exist
(e.g.,&nbsp; Myers [EUROCRYPT '04], Pietrzak [CRYPTO '05, EUROCRYPT
'06]).<br>
<br>
We give an affirmative answer to the above question, presenting a
direct construction of adaptive PRFs from non-adaptive ones. The
suggested construction is extremely simple, a composition of the
non-adaptive PRF with an appropriate pairwise independent hash
function.
</div>
</li>

<li>
<p>   Iftach Haitner
and <a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a>&nbsp;
<br>
<strong>Coin Flipping with Constant Bias Implies
One-Way Functions</strong> [<span class=abslide>Abstract</span>]
&nbsp;[<a href="papers/CoinFlipping/Seminar.pptx">Slides</a>]&nbsp;<br>
 SIAM
Journal of Computing 2013   <a  href="http://epubs.siam.org/doi/abs/10.1137/120887631">[link]</a> <br>
FOCS 2011   <a href="papers/CoinFlipping/FOCS.pptx">[PDF]</a><br>
Draft of full version <a href="papers/CoinFlipping/CoinFlippingtoOWF.pdf">[PDF]</a></p>

<div class="box"  >
 It is
well known (c.f., Impagliazzo and Luby [FOCS '89]) that the existence
of almost all ``interesting" cryptographic applications, i.e., ones
that cannot hold information theoretically, implies one-way functions.
An important exception where the above implication is not known,
however, is the case of coin-flipping protocols. Such protocols allow
honest parties to mutually flip an unbiased coin, while guaranteeing
that even a cheating (efficient) party cannot bias the output of the
protocol by much. While Impagliazzo and Luby proved that coin-flipping
protocols that are safe against negligible bias do imply one-way
functions, and, very recently, Maji, Prabhakaran, and Sahai [FOCS '10]
proved the same for constant-round protocols (with any non-trivial
bias). For the general case, however, no such implication was known.
<br>
We make progress towards answering the above fundamental question,
showing that (strong) coin-flipping protocols safe against a constant
bias (concretely, \frac{\sqrt2 -1}2 - o(1)) imply one-way functions.


</div>
</li>


<li>
<p> <a href="http://www.cs.nyu.edu/%7Edodis/">Yevgeniy Dodis</a>,

Iftach Haitner and <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>On the
Instantiability of Hash-and-Sign RSA Signatures</strong> [<span class=abslide>Abstract</span>] [<a href="papers/FullDomainHash/seminar.pptx">Slides</a>]&nbsp;<br>
TCC 2012 <a href="papers/FullDomainHash/FDH_TCC.pdf">[PDF]</a><br>
Draft of full version
[<a href="papers/FullDomainHash/FDH.pdf">PDF</a>]</p>

<div class="box"  >
 The
hash-and-sign RSA signature is one of the most elegant and well known
signatures schemes, extensively used in a wide variety of cryptographic
applications. Unfortunately, the only existing analysis of this popular
signature scheme is in the random oracle model, where the resulting
idealized signature is known as the <em>RSA Full Domain Hash</em>
signature scheme (RSA-FDH). In fact, prior work has shown several
``uninstantiability'' results for various abstractions of RSA-FDH,
where the RSA function was replaced by a family of trapdoor random
permutations, or the hash function instantiating the random oracle
could not be keyed. These abstractions, however, do not allow the
reduction and the hash function instantiation to use the algebraic
properties of RSA function, such as the multiplicative group structure
of <strong>Z</strong><strong><sub>n</sub>*</strong>. In contrast, the multiplicative property of
the RSA function is critically used in many standard model analyses of
various RSA-based schemes.<br>
<br>
Motivated by closing this gap, we consider the setting where the RSA
function representation is generic (i.e., black-box) <strong>but
multiplicative</strong>,
whereas the hash function itself is in the standard
model, and can be keyed and exploit the multiplicative properties of
the RSA function.
This setting abstracts all known techniques for designing provably
secure RSA-based signatures in the standard model, and aims to address
the main
limitations of prior uninstantiability results.
Unfortunately, we show that it is still impossible to reduce the
security of
RSA-FDH to any natural assumption even in our model. Thus, our result
suggests that in order to prove the security of a given instantiation
of RSA-FDH, one should use a non-black box security proof, or use
specific properties of the RSA group
that are not captured by its multiplicative structure alone.<br>
<br>
We complement our negative result with a positive result, showing that
the RSA-FDH signatures <strong>can</strong> be proven
secure under the <strong>standard</strong> RSA assumption,
provided that the number<br>
of signing queries is <strong>a-priori bounded</strong>.
 
</div>
</li>


<li><p>
Iftach
Haitner,  <a name="BBMPC"></a>  <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a>,
<a href="http://www.cs.technion.ac.il/%7Eeyalk/">Eyal
Kushilevitz</a>, <a href="http://u.cs.biu.ac.il/%7Elindell//">Yehuda
Lindell</a> and <a href="http://www.cs.technion.ac.il/%7Eerez/">Erez Petrank</a>
 <br>
<strong>Black-Box
Constructions of Protocols for Secure Computation</strong> [<span class=abslide>Abstract</span>]&nbsp;<br>
SIAM Journal of
Computing 2011<i>
</i>  

 <a  href="http://epubs.siam.org/doi/pdf/10.1137/100790537">[link]</a><br>
Draft of full version <a href="papers/BlackBoxMPC/black-box-mpc.pdf">[PDF]</a>


</p><div class="box" >
It is
well known that secure computation without an honest majority
requires computational assumptions. An interesting question that
therefore arises relates to the way such computational assumptions are
used. Specifically, can the secure protocol use the underlying
primitive (e.g., a one-way trapdoor permutation) in a black-box way,
treating it as an oracle, or must it be non-black-box (by referring to
the code that computes the primitive)? <br>
Despite the fact that many general constructions of cryptographic
schemes refer to the underlying primitive in a black-box way only,
there are some constructions that are inherently nonblack-box. Indeed,
all known constructions of protocols for general secure computation
that are secure in the presence of a malicious adversary and without an
honest majority use the underlying primitive in a nonblack-box way
(requiring to prove in zero-knowledge statements that relate to the
primitive).<br>
In this paper, we study whether such nonblack-box use is essential. We
answer this question in the negative. Concretely, we present a fully
black-box reduction from oblivious transfer with security against
malicious parties to oblivious transfer with security against
semi-honest parties. As a corollary, we get the first constructions of
general multiparty protocols (with security against malicious
adversaries and without an honest majority) which only make a black-box
use of semi-honest oblivious transfer, or alternatively a black-box use
of lower-level primitives such as enhanced trapdoor permutations or
homomorphic encryption. 
</div>
</li>


<li>
<p>Iftach
Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a>, and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
<b>Efficiency Improvements in Constructing Pseudorandom Generators from
One-way Functions</b>&nbsp; [<span class=abslide>Abstract</span>]
 <br>

SIAM Journal of Computing
2013    <a  href="http://epubs.siam.org/doi/abs/10.1137/100814421">[link]</a><br>
Annual ACM Symposium on Theory of Computing (STOC), 2010  <a href="papers/HillRevisted/HillRevisted_STOC.pdf">[PDF]</a><br>
Draft of full version <a href="papers/HillRevisted/HillRevisted_Full.pdf">[PDF]</a> <img src="up7.png" class=update1></p>

<div class="box" >
We
give a new construction of pseudorandom generators from any one-way
function. The construction achieves better parameters and is simpler
than that given in the seminal work of Håstad, Impagliazzo, Levin and
Luby [SICOMP '99]. The key to our construction is a new notion of <strong>next-block
pseudoentropy</strong>, which is inspired by the notion of
``inaccessible entropy'' recently introduced in [Haitner, Reingold,
Vadhan and Wee STOC '09]. An additional advantage over all previous
constructions is that our pseudorandom generators are highly
parallelizable and invoke the one-way function in a non-adaptive
manner. Using [Applebaum, Ishai and Kushilevitz SICOMP '06], this
implies the existence of pseudorandom generators in NC<sup>0</sup>
based on the existence of one-way functions in NC<sup>1</sup>.

</div>
</li>

<li>
<p><a href="http://www.cs.princeton.edu/%7Eboaz/">Boaz Barak</a>,
Iftach
Haitner,  <a href="http://homepages.cwi.nl/%7Ehofheinz/">Dennis Hofheinz</a>
and <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval
Ishai</a><br>
   <strong>Bounded
Key-Dependent Message Security</strong> [<span class=abslide>Abstract</span>]<br>
Advances
in Cryptology - Eurocrypt, 2010
<a href="papers/BoundedKDM/boundedkdm_EuroCrypt.pdf">[PDF]</a><br>
Draft of full version <a href="papers/BoundedKDM/boundedkdm.pdf">[PDF]</a></p>


<div class="box" >
We
construct the first public-key encryption scheme that is proven secure
(in the standard model,<br>
under standard assumptions) even when the attacker gets access to
encryptions of arbitrary<br>
efficient functions of the secret key. Specifically, under either the
DDH or LWE assumption, for<br>
every polynomials L and
N we obtain a
public-key encryption scheme that resists key-dependent<br>
message (KDM) attacks for up to N(k)
public keys and functions <strong>circuit size</strong> up
to<br>
L(k), where k denotes the size of the secret
key. We call such a scheme <strong>bounded KDM<br>
secure</strong>. Moreover, we show that our scheme suffices for
one of the important applications of KDM<br>
security: ability to securely instantiate symbolic protocols with
axiomatic proofs of security.<br>
<br>
We also observe that any fully homomorphic encryption scheme which
additionally enjoys circular<br>
security and circuit privacy is <strong>fully KDM secure</strong>
in the sense that the encryption and<br>
decryption algorithms can be independent of the polynomials 
L and N as
above. Thus, the recent<br>
fully homomorphic encryption scheme of Gentry (STOC 2009) is fully KDM
secure under certain<br>
non-standard hardness assumptions.<br>
<br>
Previous works obtained either full KDM security in the random oracle
model<br>
(Black et al., SAC 2002) or security with respect to a very restricted
class of<br>
functions (e.g., clique/circular security and affine functions, Boneh
et al., CRYPTO 2008,<br>
and Applebaum et al., CRYPTO 2009).<br>
<br>
Our main result is based on a combination of the circular-secure
encryption scheme of either<br>
Boneh et al. <strong>or</strong> Applebaum et al. with
Yao's garbled circuit construction.<br>
<br>
Finally, we extend the impossibility result of Haitner and Holenstein
(TCC 2009), showing that it<br>
is impossible to prove KDM security against a family of query functions
that contains exponentially<br>
hard pseudorandom functions, using only <strong>black-box</strong>
access to the query function and the<br>
adversary attacking the scheme. This proves that the non-black-box
usage of the query function in<br>
our proof of security makes to the KDM query function is <strong>inherent</strong>.
</div>
</li>

<li>
<p>Iftach
Haitner, <a href="http://research.microsoft.com/users/thomahol/">Thomas
Holenstein</a>,
   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a>,
<a href="http://www.eecs.harvard.edu/%7Esalil/">Salil
Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
 <b>Universal
One-Way Hash Functions via Inaccessible Entropy </b> [<span class=abslide>Abstract</span>]
 <br>
 Advances
in Cryptology - Eurocrypt, 2010 [<a href="papers/RompelRevisted/RompelRevisited-EurocryptCamera.pdf">PDF</a>]<br>
Draft of full version <a href="papers/RompelRevisted/RompelRevisited-eprint.pdf">[PDF]</a></p>


<div class="box"  >
This
paper revisits the construction of Universally One-Way Hash Functions
(UOWHFs) from any one-way function due to Rompel (STOC 1990). We give a
simpler construction of UOWHFs which also obtains better efficiency and
security. The construction exploits a strong connection to the recently
introduced notion of
<strong>inaccessible entropy</strong> (Haitner et
al. STOC 2009). With this perspective, we observe that a small tweak of
any one-way function
f is already a
weak form of a UOWHF: Consider
F(x,i) that
outputs the i-bit long
prefix of f(x). If F were a UOWHF then given a
random x and
i it would be
hard to come up with
x' ≠ x such
that F(x,i)=F(x',i).
While this may not be the case, we show (rather easily) that it is hard
to sample x' with
almost full entropy among all the possible such values of x'. The rest of our construction
simply amplifies and exploits this basic property.<br>
<br>
With this and other recent works we have that the constructions of
three fundamental cryptographic primitives (Pseudorandom Generators,
Statistically Hiding Commitments and UOWHFs) out of one-way functions
are to a large extent unified. In particular, all three constructions
rely on and manipulate computational notions of entropy in similar
ways. Pseudorandom Generators rely on the well-established notion of
pseudoentropy, whereas Statistically Hiding Commitments and UOWHFs rely
on the newer notion of inaccessible entropy.
</div>
</li>


<li>
<p>Iftach Haitner,  <a href="http://www.cs.princeton.edu/%7Emohammad/">Mohammad
Mahmoody</a> and <a href="http://www.cs.princeton.edu/%7Edxiao/"> David Xiao</a>
<br>
<strong>A New Sampling Protocol and Applications to
Basing Cryptographic Primitives on the Hardness of NP [</strong><span class=abslide>Abstract</span>] <br>
 IEEE Conference on Computational
Complexity&nbsp; (CCC), 2010  [<a href="papers/SampleWithSize/SampleWithSize_CCC.pdf">PDF</a>]<br>
Draft of full version [<a href="papers/SampleWithSize/SampleWithSize.pdf">PDF</a>]</p>
<div class="box" >
We investigate the question
of what languages can be decided efficiently with the help of a<br>
recursive collision-finding oracle. Such an oracle can be used to break
collision-resistant hash<br>
functions or, more generally, statistically hiding commitments. The
oracle we consider Sam<sub>d,</sub><br>
where d is the
recursion depth, is based on the identically-named oracle defined in
the work of<br>
Haitner et al. (FOCS '07).
Our main result is a constant-round public-coin protocol AM-Sam<br>
that allows an efficient&nbsp; verifier to emulate a Sam<sub>d</sub>
oracle for any constant depth d =
O(1) with the<br>
help of a BPP<sup>NP</sup>
prover. AM-Sam allows
us to conclude that if L
is decidable by a k-adaptive<br>
randomized oracle algorithm with access to a &nbsp;Sam<sub>O(1)</sub>
oracle, then
L∈AM[k]∩coAM[k].<br>
The above yields the following corollary: assume there exists an
O(1)-adaptive
reduction that<br>
bases constant-round statistically hiding commitment on NP-hardness,
then NP ⊆ coAM and<br>
the polynomial hierarchy collapses. The same result holds for any
primitive that can be broken<br>
by Sam<sub>O(1)</sub>
including collision-resistant hash functions and O(1)-round oblivious transfer
where<br>
security holds statistically for one of the parties. We also obtain
non-trivial (though weaker)<br>
consequences for k-adaptive
reductions for any k = poly(n).
Prior to our work, most results in<br>
this research direction either applied only to non-adaptive reductions (Bogdanov and Trevisan,<br >
SIAM J. of Comp. '06)
or to primitives with special regularity properties (Brassard FOCS '79,<br>
Akavia et al., FOCS '06).<br>
The main technical tool we use to prove the above is a new
constant-round public-coin<br>
protocol (SampleWithSize)
that we believe may be interesting in its own right, and that
guarantees the following. Given an efficient function f on n
bits, let D be the
output distribution<br>
D = f(U<sub>n</sub>),
then SampleWithSize
allows an efficient verifier Arthur to use an all-powerful prover<br>
Merlin's help to sample a random y ←
D along with a good multiplicative approximation of the<br>
probability p<sub>y</sub>
= Pr<sub>y' ← D</sub>[y' = y]. The crucial
feature of SampleWithSize
is that it extends even<br>
to distributions of the form D = f(U<sub>S</sub>),
where U<sub>S</sub>
is the uniform distribution on an efficiently<br>
decidable subset S ⊆{0.1}<sup>n</sup>
(such D are called <em>efficiently
samplable with post-selection</em>), as<br>
long as the verifier is also given a good approximation of the value |S|.</p>
</div>
</li>

<li>
<p>Iftach
Haitner<br>
<strong>A
Parallel Repetition Theorem for Any Interactive Argument </strong>[<span class=abslide>Abstract</span>] [<a href="papers/ArgumentPR/Seminar.pptx">Slides</a>] <br>
SIAM Journal of Computing 2013    <a  href="http://epubs.siam.org/doi/abs/10.1137/100810630">[link]</a><b><br>
</b>IEEE Symposium on Foundations of
Computer Science (FOCS), 2009<br>
Draft of full
version <a href="papers/ArgumentPR/ArgumentPR.pdf">[PDF]</a></p>

<div class="box"  >
The
question whether or not parallel repetition reduces the soundness error
is a fundamental question in the theory of protocols. While parallel
repetition reduces (at an exponential rate) the error in interactive
proofs and (at a weak exponential rate) in special cases of interactive
arguments (e.g., 3-message protocols - Bellare, Impagliazzo and Naor
[FOCS '97], and public-coin protocols - Håstad, Pass, Pietrzak and
WikstrÄom [Manuscript '08]), Bellare et. al gave example of interactive
arguments for which parallel repetition does not reduce the soundness
error at <strong>all.<br>
</strong>We show that by slightly modifying any
interactive argument, in a way that preserves its completeness and only
slightly deteriorates its soundness, we get a protocol for which
parallel repetition does reduce the error at a weak exponential rate.
In this modified version, the verifier flips at the beginning of each
round an (1 - (1/4m), 1/4m) biased
coin (i.e., 1 is tossed
with probability
1/4m), where m is the round complexity of the
(original) protocol. If the coin is one, the verifier halts the
interaction and accepts, otherwise it sends the same message that the
original verifier would. At the end of the protocol (if reached), the
verifier accepts if and only if the original verifier would.

</div>
</li>

<li>
<p><a name="HONRV"></a>Iftach
Haitner, Minh-Huyen Nguyen, Shien Jin Ong,
  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a> and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
 <b>Statistically
Hiding Commitments and Statistical Zero-Knowledge Arguments from Any
One-Way Function</b> [<span class=abslide>Abstract</span>]  <br>
SIAM Journal of
Computing 2009  <a  href="http://epubs.siam.org/doi/pdf/10.1137/080725404">[link]</a><br>
Draft of full
version
 <a href="papers/HNORV/HNORV-sicomp.pdf">[PDF]</a></p>
</li>



<li>
<p>Iftach
Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a>,
<a href="http://www.eecs.harvard.edu/%7Esalil/">Salil
Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
 <b>Inaccessible
Entropy</b> [<span class=abslide>Abstract</span>]
[<a href="papers/AccessibleEntropy/AccEntSemniar.pptx">Slides</a>] [<a href="http://intractability.princeton.edu/videos/stream/videoplay.html?videofile=cs/IW2009-500kb/Iftach%20Haitner.mp4">Video</a>
(appx. 1 hour)]<br>
 Annual ACM Symposium on
Theory of Computing (STOC), 2009  [<a href="papers/AccessibleEntropy/AE-stoc.pdf">PDF</a>]
<br>
Draft of full
version <a href="papers/AccessibleEntropy/AccessibleEntropy_full.pdf">[PDF]</a></p>


<div class="box"  >
We put
forth a new computational notion of entropy, which measures the<br>
(in)feasibility of sampling high entropy strings that are consistent
with a<br>
given protocol. Specifically, we say that the i’th round of a protocol<br>
(A,B) has <em>accessible
entropy</em> at most k,
if no polynomial-time strategy<br>
A* can
generate messages for A
such that the entropy of its message in the i’th round has entropy
greater than k when
conditioned both on prior<br>
messages of the protocol and on prior coin tosses of A*. As applications of this
notion, we

<ul>
<li>Give a much simpler and more efficient
construction of statistically hiding<br>
commitment schemes from arbitrary one-way functions.<br>
</li>
<li>Prove that constant-round statistically hiding
commitments are necessary<br>
for constructing constant-round zero-knowledge proof systems for NP that<br>
remain secure under parallel composition (assuming the existence of
one-way<br>
functions).</li>
</ul>

</div>
</li>

<li>
<p>Iftach
Haitner,   <a href="http://www.eecs.harvard.edu/%7Ealon/">Alon Rosen</a>
and  <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
 <b>On the
(Im)Possibility of Arthur-Merlin Witness Hiding Protocols  </b>[<span class=abslide>Abstract</span>] [<a href="papers/WitnessHiding/WitnessHidingTCC.ppsx">Slides</a>]<br>
Theory of
Cryptography Conference (TCC), 2009<b>
</b> [<a href="papers/WitnessHiding/WitnessHidingLB.pdf">PDF</a>]</p>
<div class="box" >
The
concept of <em>witness-hiding</em> suggested by Feige and
Shamir is a natural relaxation of zero-knowledge. In this paper we
identify
languages and distributions for which many known constant-round
public-coin
protocols with negligible soundness cannot be shown to witness-hiding
using
black-box techniques.<br>
<br>
In particular, our results imply that it is impossible to prove that
parallel
repetition of 3-Colorability or Hamiltonicity is witness-hiding for
distributions that support instances with exactly one witness, if the
proof of
security is by a black-box reduction that is <em>independent</em>
of the
choice of the commitment scheme used in the protocol. This lower bound
conceptually matches an upper bound of Feige and Shamir that uses such
a
black-box reduction to show that parallel repetition of 3-Colorability
or
Hamiltonicity <em>is</em>
witness-hiding for distributions with ``two independent witnesses.<br>
<br>
We also consider black-box reductions for 3-Colorability or
Hamiltonicity that <em>depend</em> on a specific
implementation of the commitment scheme.
While we cannot rule out such reductions completely, we show that
``natural
reductions" cannot bypass the limitations above.<br>
<br>
Our proofs use techniques developed by Goldreich and Krawczyk for the
case of
zero knowledge. The setup of witness-hiding, however, presents new
technical and
conceptual difficulties that do not come up in the setup of
zero-knowledge. The
high level idea is that if a black-box reduction establishes the
witness-hiding
property for a protocol that is also a proof of knowledge, then this
latter
property can be used ``against the reduction" to find witnesses
unconditionally.
</div>
</li>


<li>
<p>Iftach Haitner and
<a href="http://research.microsoft.com/users/thomahol/">Thomas
Holenstein</a><br>
<b>On the
(Im)Possibility of Key Dependent Encryption</b> [<span class=abslide>Abstract</span>] [<a href="papers/AccessibleEntropy/AccEntSemniar_f.pptx">Slides</a>] <br>
Theory of
Cryptography Conference (TCC), 2009  [<a href="papers/KDI/KDI-TCC_CR.pdf">PDF</a>]<br>
Draft of full version <a href="papers/KDI/KDI-full.pdf">[PDF]</a></p>
<div class="box"  >

<p>We study the possibility of constructing encryption
schemes secure<br>
under
messages that are chosen depending on the key
k of
the<br>
encryption scheme itself. We give the following separation results that<br>
hold both in the private and in the public key settings:</p>
<ul>
<li>Let H
be the family of poly(n)-wise independent<br>
hash-functions. There exists no fully-black-box reduction from an<br>
encryption scheme secure against key-dependent messages to one-way<br>
permutations (and also to families of trapdoor permutations) if the<br>
adversary can obtain encryptions of h(k)
for h ∈ H.</li>
<li>&nbsp;There exists no reduction from an
encryption scheme secure<br>
against key-dependent messages to, essentially, <em>any</em><br>
cryptographic assumption, if the adversary can obtain an encryption<br>
of g(k) for an <em>arbitrary</em>
g, as long
as the reduction's<br>
proof of security treats both the adversary and the function g as<br>
black boxes.</li>
</ul>

</div>
</li>


<li>
<p>Iftach Haitner<br>
<b>New
Implications and Improved Efficiency of
Constructions Based on One-way Functions</b><br>
PhD. Thesis,
2008 [<a href="papers/PhDThesis/FullThesis.pdf">PDF</a>]</p>
</li>

<li>
<p>Iftach Haitner<br>
<b>Semi-Honest to
Malicious Oblivious Transfer -- The Black-Box Way </b>[<span class=abslide>Abstract</span>] [<a href="papers/SemiHonestToMalicious/SemiToMal_f.ppt">Slides</a>]<br>
Theory of
Cryptography Conference (TCC), 2008&nbsp; [<a href="papers/SemiHonestToMalicious/SemiHonestToMalicious-TCC.pdf">PDF</a>] <br>
Full
version is part of   <a href="papers/HNORV/HNORV-sicomp.pdf">[</a><a href="#BBMPC">Black-Box Constructions of Protocols for
Secure Computation</a>]</p>

<div class="box"  >
Until
recently, all known constructions of oblivious transfer protocols based
on general hardness assumptions had the following form. First, the
hardness assumption is used in a black-box manner (i.e., the
construction uses only the input/output behavior of the primitive
guaranteed by the assumption) to construct a <em>semi-honest</em>
oblivious transfer, a protocol whose security is guaranteed to hold
only against adversaries that follow the prescribed protocol. Then, the
latter protocol is ``compiled" into a (malicious) oblivious transfer
using non-black techniques (a Karp reduction is carried in order to
prove an NP statement in zero-knowledge). In their recent breakthrough
result, Ishai, Kushilevitz, Lindel and Petrank (STOC '06) deviated from
the above paradigm, presenting a black-box reduction from oblivious
transfer to enhanced trapdoor permutations and to homomorphic
encryption. Here we generalize their result, presenting a black-box
reduction from oblivious transfer to semi-honest oblivious transfer.
Consequently, oblivious transfer can be black-box reduced to each of
the hardness assumptions known to imply a semi-honest oblivious
transfer in a black-box manner. This list currently includes beside the
hardness assumptions used by Ishai et al. also the existence of
families of dense trapdoor permutations and of non trivial
single-server private information retrieval. 
</div>
</li>


<li>
<p>Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan
J. Hoch</a> and&nbsp; <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a>
<br>
<b>A Linear Lower Bound on the Communication
Complexity of Single-Server Private Information Retrieval</b> [<span class=abslide>Abstract</span>]&nbsp; [<a href="papers/PIRLowerBound/PIRLowerBound.ppt">Slides</a>] <br>
Theory of Cryptography Conference (TCC), 2008
[<a href="papers/PIRLowerBound/PIRLowerBound.pdf">PDF</a>]<br>
<o:p>Full version is
part of   <a href="papers/HNORV/HNORV-sicomp.pdf">[</a><a href="#HHRSJoint">Finding Collisions in Interactive
Protocols — Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>]</p>
<div class="box"  >
We
study the communication complexity of single-server Private Information
Retrieval (PIR) protocols that are based on fundamental cryptographic
primitives in a black-box manner. In this setting, we establish a tight
lower bound on the number of bits communicated by the server in any
polynomially-preserving construction that relies on trapdoor
permutations. More specifically, our main result states that in such
constructions Ω(n) bits
must be communicated by the server, where n
is the size of the server's database, and this improves the Ω(n / log n) lower bound due to
Haitner, Hoch, Reingold and Segev (FOCS '07). Therefore, in the setting
under consideration, the naive solution in which the user downloads the
entire database turns out to be optimal up to constant multiplicative
factors. We note that the lower bound we establish holds for the most
generic form of trapdoor permutations, including in particular enhanced
trapdoor permutations.<br>
<br>
Technically speaking, this paper consists of two main contributions
from which our lower bound is obtained. First, we derive a tight lower
bound on the number of bits communicated by the sender during the
commit stage of any black-box construction of a statistically-hiding
bit-commitment scheme from a family of trapdoor permutations. This
lower bound asymptotically matches the upper bound provided by the
scheme of Naor, Ostrovsky, Venkatesan and Yung (CRYPTO '92). Second, we
improve the efficiency of the reduction of statistically-hiding
commitment schemes to low-communication single-server PIR, due to
Beimel, Ishai, Kushilevitz and Malkin (STOC '99). In particular, we
present a reduction that essentially preserves the communication
complexity of the underlying single-server PIR protocol. 
</div>
</li>


<li>
<p>Iftach Haitner,
<a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan
J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a> and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a>
<br>
<b>Finding Collisions in Interactive Protocols -- A
Tight Lower Bound on the Round Complexity of Statistically-Hiding
Commitments</b> [<span class=abslide>Abstract</span>]
[<a href="papers/FindingCollisions/FindingCollisions.pps">Slides</a>]<br>
IEEE Symposium on Foundations of Computer Science (FOCS), 2007 [<a href="papers/FindingCollisions/FindingCollisions-FOCS.pdf">PDF</a>]
<br>
Full version is part of   <a href="papers/HNORV/HNORV-sicomp.pdf">[</a><a href="#HHRSJoint">Finding Collisions in Interactive
Protocols — Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>]</p>
</li>

<li>
<p>Iftach Haitner
and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>Statistically Hiding
Commitment from Any One-Way Function </b>[<span class=abslide>Abstract</span>] [<a href="papers/SCfromOWF/SCfromOWF.pps">Slides</a>]<br>
 Annual ACM Symposium on
Theory of Computing (STOC), 2007
<a href="papers/SCfromOWF/SCfromOWF-STOC.pdf">[PDF]</a>
Full version is
part of   <a href="papers/HNORV/HNORV-sicomp.pdf">[</a><a href="#HONRV">Statistically Hiding Commitments and
Statistical Zero-Knowledge Arguments from Any One-Way Function</a>]</p>
<div class="box" >
We
give a construction of statistically-hiding commitment schemes (ones
where the hiding property holds information theoretically), based on
the minimal cryptographic assumption that one-way functions exist. Our
construction employs two-phase commitment schemes, recently constructed
by Nguyen, Ong and Vadhan (FOCS `06), and universal one-way hash
functions introduced and constructed by Naor and Yung (STOC `89) and
Rompel (STOC `90). 
</div>
</li>

<li>
<p>Iftach Haitner and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>A New Interactive
Hashing Theorem </b> [<span class=abslide>Abstract</span>]
[<a href="papers/IneractiveHashing/IHSeminar_F.ppt">Slides</a>]<br>

Journal of
Cryptology 2014&nbsp;
 <a  href="http://link.springer.com/article/10.1007/s00145-012-9139-0">[link]</a>
 <br>
IEEE Conference on Computational Complexity&nbsp; (CCC), 2007
<a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[PDF]</a><br>
Draft of full version  <a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[PDF]</a></p>
<div class="box" >
Interactive
hashing, introduced by Naor,
Ostrovsky, Venkatesan and Yung (CRYPTO '92),
plays an important role in many cryptographic protocols. In particular,
interactive hashing is a major component in all known constructions
(which are based on general one-way permutations and one-way functions)
of statistically hiding commitment schemes and of statistical
zero-knowledge arguments. Interactive hashing with respect to a one-way
permutation f, is a
two-party protocol that enables a sender that knows y=f(x) to transfer a random hash
z=h(y) to a
receiver. The
receiver is guaranteed that the sender is committed to y (in the sense that it cannot
come up with x and
x' such that f(x) ≠ f(x'), but h(f(x))=h(f(x'))=z). The sender
is guaranteed
that the receiver does not learn any additional information on y. In particular, when h  is a two-to-one hash
function, the receiver does not learn which of the two preimages {y,y'}=h<sup>-1</sup>(z)
 is the one the sender can invert with respect
to f.<br>
<br>
This paper reexamines the notion of interactive hashing. We give an
alternative proof for the Naor et al. protocol, which seems
significantly simpler and more intuitive than the original one.
Moreover, the new proof achieves much better parameters (in terms of
how security preserving the reduction is). Finally, by applying our new
proof to a close variant of the Naor et al. protocol, we achieve a more
versatile interactive hashing theorem for a more general setting than
that of the Naor et al. protocol. 
</div>

</li>


<li>
<p>Iftach Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>,
and  <a name="RandIt"></a>
Omer Reingold<br>
<b>On the Power of the
Randomized Iterate</b> [<span class=abslide>Abstract</span>] [<a href="papers/RandomizedIteate/Randomized_Iterate.pps">Slides</a>]<br>
 SIAM
Journal of Computing 2011   <a  href="http://epubs.siam.org/doi/pdf/10.1137/080721820">[link]</a><br>
Advanced in Cryptology - CRYPTO, 2006 <a href="papers/RandomizedIteate/Randomized_Iterate_CryptoCR.pdf">[PDF]</a><br>
 Draft of full version  <a href="papers/RandomizedIteate/RandomIterate.pdf">[PDF]</a></p>

<div class="box"  >
We
consider two of the most fundamental theorems in Cryptography. The
first, due to Håstad, Impagliazzo, Levin and Luby (STOC '89, STOC '90,
SIAM J. on Computing '99), is that pseudorandom generators can be
constructed from any one-way function. The second, due to Yao (FOCS
'82), states that the existence of weak one-way functions implies the
existence of full fledged one-way functions. These powerful
plausibility results shape our understanding of hardness and randomness
in Cryptography, but unfortunately their proofs are not as tight (i.e.,
security preserving) as one may desire..r&gt;<br>
This work revisits a technique that we call the <i>randomized
iterate</i>, introduced by Goldreich, Krawczyk and Luby (SIAM J.
on Computing '93). This technique was used by Goldreich et al. to give
a construction of pseudorandom generators from regular one-way
functions. We simplify and strengthen this technique in order to obtain
a similar construction where the seed length of the resulting
generators is as short as Θ(n log n)
rather than Θ(n<sup>3</sup>)
achieved by Goldreich et al. Our technique has the potential of
implying seed-length Θ(n),
and the only bottleneck for such a result is the parameters of current
generators against space bounded computations. We give a construction
with similar parameters for security amplification of regular one-way
functions. This improves upon the construction of Goldreich,
Impagliazzo, Levin, Venkatesan and Zuckerman (FOCS '90) in that the
construction does not need to ``know" the regularity parameter of the
functions (in terms of security, the two reductions are incomparable).
In addition, we use the randomized iterate to show a construction of a
pseudorandom generator based on an exponentially hard one-way function
that has seed length of only Θ(n<sup>2</sup>).
This improves a recent result of Holenstein (TCC '06) that shows a
construction with seed length Θ(n<sup>5</sup>)
based on such one-way functions. Finally, we show that the randomized
iterate may even be useful in the general context of Håstad et al. In
particular, we use the randomized iterate to replace the basic building
block of the Håstad et al. construction. Interestingly, this
modification improves efficiency by an n<sup>3</sup>
factor and reduces the seed length to Θ(n<sup>7</sup>)
(which also implies improvement in the security of the construction). 
</div>
</li>

<li>
<p>Iftach Haitner,  <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>
and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>On Efficient
Pseudorandom Generators from Exponentially Hard One-Way Functions</b>
[<span class=abslide>Abstract</span>]
[<a href="papers/RandomizedIteate/PrgFromHard.pps">Slides</a>]<br>
International Colloquium on Automata, Languages and Programming - ICALP, 2006  <a href="papers/RandomizedIteate/PrgFromHard-ICALP.pdf">[PDF]</a>
<br>
 Full version is part of   <a href="papers/HNORV/HNORV-sicomp.pdf">[</a><a href="#RandIt">On the
Power of the Randomized Iterate</a>]</p>
<div class="box"  >
We
show a construction of a pseudorandom generator from any exponentially
hard one-way function with a blowup of only Θ(n<sup>2</sup>).
This Improves the recent Θ(n<sup>5</sup>) construction of
Holenstein (TCC '06). Our technique uses the tools recently presented
in Haitner et al. (Crypto '06) for the setting of regular one-way
functions, and further develops them. 
</div>
</li>


<li>
<p>Iftach
Haitner, Omer Horvitz, <a href="http://www.cs.umd.edu/%7Ejkatz/">Jonathan
Katz</a>, Chiu-Yuen Koo, Ruggero Morselli and <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
<b>Reducing Complexity
Assumptions for Statistically-Hiding Commitment </b>[<span class=abslide>Abstract</span>] [<a href="papers/SCfromRegularOWF/SCfromRegularOWF.pps">Slides</a>]<b> </b><br>
Journal of Cryptology 2009 <a  href="http://link.springer.com/content/pdf/10.1007/s00145-007-9012-8">[link]</a><br>
Advances in Cryptology - Eurocrypt,
2005  <a href="papers/SCfromRegularOWF/SCfromRegularOWF-eurocrypt.pdf">[PDF]</a>
<br>
Draft
of full version  <a href="papers/SCfromRegularOWF/SCfromRegularOWF-JOC.pdf">[PDF]</a></p>
<div class="box"  >
We
revisit the following question: <em>what are the minimal
assumptions needed to construct statistically-hiding commitment schemes</em>?
Naor et al. show how to construct such schemes based on any one-way
permutation. We improve upon this by showing a construction based on
any approximable preimage-size one-way function.
These are one-way functions for which it is possible to efficiently
approximate the number of pre-images of a given output. A special case
is the class of <em>regular</em> one-way functions where
all points in the image of the function have the same (known) number of
pre-images.<br>
<br>
We also prove two additional results related to statistically-hiding
commitment. First, we prove a (folklore) <em parallel="" composition="" theorem=""></em>showing, roughly
speaking, that the statistical hiding property of any such commitment
scheme is amplified exponentially when multiple independent parallel
executions of the scheme are carried out. Second, we show a <em>compiler</em>
which transforms any commitment scheme which is statistically hiding
against an honest-but-curious receiver into one which is statistically
hiding even against a malicious receiver. 
</div>
</li>

<li>
<p>Iftach
Haitner<b><br>
Implementing Oblivious Transfer Using a Collection of Dense Trapdoor
Permutations</b> [<span class=abslide>Abstract</span>]
 [<a href="papers/OTDenseTDP/OTDenseTDP.pps">Slides</a>]<br>
 Theory of
Cryptography Conference (TCC), 2004  <a href="papers/OTDenseTDP/OT_Dense_TCC.pdf">[PDF]</a> <br>
Draft of full
version <a href="papers/OTDenseTDP/OTDenseTDP.pdf">[PDF]</a></p>
</li>
</ul>
</div> <!------------end wrapper----------------------->


<p align="justify"><!-- Start of StatCounter Code -->
</p>
<p align="justify"> </p>
</div> <!--wrapall-->
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-4194129-2']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body></html>