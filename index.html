  <!DOCTYPE html>
<html><head><title>Iftach Haitner's Home Page</title>
<script type="text/javascript" src="jquery.js"></script>
<style>
BODY { font-family :  verdana, arial, helvetica, sans-serif; BACKGROUND-COLOR: #eee ; color : #333  ; }
.shadow1 {box-shadow: 5px 5px 20px #888888; line-height : 150% ;}
.shadow2 {box-shadow: 5px 5px 20px #888888; border-radius : 8px }
  #iftach_pic {  background-image: url(iftach_pic_back.jpg);width : 192px ; height:233px  }
   .backup {   background-position :top   }
  .backdown {    background-position : bottom   }
 #wrapall {  max-width : 1100px ; margin:auto}
  #wrapper {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; margin-left : 30px ; padding-bottom : 30px }
strong, b {    color : #636363 }
   .abslide { color : #3956CC  ; cursor : pointer ;  }
 .abslide:hover {  text-decoration: underline;   }
 #wrapper div.box {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; margin-bottom : 20px}
  #wrapper div.box p {    margin : 0px ; }
    #topwrap {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; ; margin-left : 30px ;  padding-bottom : 30px }
   #topwrap div.top {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; line-height : 150% ;}
      #topwrap div.top a:hover {      text-decoration : underline     }
    #pub1 li {      line-height : 150% ; }
     a {      color : #3956CC  ; text-decoration : none   }

  .boxtop { color : #3956CC  ; cursor : pointer ; font-size :150%  }
 .boxtop:hover {  text-decoration: underline;   }
    #topwrap  ul {     list-style: none   }
      h1 {      font-size : 150% ; color :  #636363   }
    h2 {     font-size : 120%  }
 .update {  position : relative;top : 2px ; left : 10px ;border : 1px solid #91BF46 ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; padding-right : 0px; padding-left: 0px }
   .update1 {  position : relative;top : 2px ; left : 10px ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; }

 .blu1 {color: #000080;}
.blu2 {color: #003FFF; }



</style>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="Iftach Haitner, Iftach, Haitner, יפתח היטנר, הייטנר, יפתח, Home Page, Cryptography">
<meta content="Iftach Haitner's Home Page" name="description">
<script language="JavaScript" type="text/JavaScript">


 $(document).ready(function(){
     $('.abslide').click(function(){$(this).closest('li').find(".box").slideToggle("slow","swing")});

     $('#iftach_pic').click(function(){$(this).toggleClass("backdown")});

     $(".boxtop").click(topslide);
   function topslide(){
   kukuclass="." +this.id  ;$(".top").hide("slow") ;
   $("#info").closest('div').find(kukuclass ).show("slow","swing")    ;    }
           });

</script>


<!-- Google Analytics -->
<script>
/**
 * Creates a temporary global ga object and loads analy  tics.js.
 * Paramenters o, a, and m are all used internally.  They could have been declared using 'var',
 * instead they are declared as parameters to save 4 bytes ('var ').
 *
 * @param {Window}      i The global context object.
 * @param {Document}    s The DOM document object.
 * @param {string}      o Must be 'script'.
 * @param {string}      g URL of the analytics.js script. Inherits protocol from page.
 * @param {string}      r Global name of analytics object.  Defaults to 'ga'.
 * @param {DOMElement?} a Async script tag.
 * @param {DOMElement?} m First script tag in document.
 */
(function(i, s, o, g, r, a, m){
  i['GoogleAnalyticsObject'] = r; // Acts as a pointer to support renaming.

  // Creates an initial ga() function.  The queued commands will be executed once analytics.js loads.
  i[r] = i[r] || function() {
    (i[r].q = i[r].q || []).push(arguments)
  },

  // Sets the time (as an integer) this tag was executed.  Used for timing hits.
  i[r].l = 1 * new Date();

  // Insert the script tag asynchronously.  Inserts above current tag to prevent blocking in
  // addition to using the async attribute.
  a = s.createElement(o),
  m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-4194129-2', 'auto'); // Creates the tracker with default parameters.
ga('send', 'pageview');            // Sends a pageview hit.
</script>

<!-- End Google Analytics -->


<!--LOAD JQUERY GOOGLE ANALYTICS OUTBOUND LINKS TRACKER - TEST-->
<script>
/* Attach tracking to all download & external links */
var _gaq = _gaq || [];

function _gaLt(event){
    var el = event.srcElement || event.target;

    /* Loop through parent elements if clicked element is not a link (ie: <a><img /></a> */
    while(el && (typeof el.tagName == 'undefined' || el.tagName.toLowerCase() != 'a' || !el.href))
        el = el.parentNode;

    if(el && el.href){
        dl = document.location;
        l = dl.pathname + dl.search;
        h = el.href;
        c = !1;
        if(h.indexOf(location.host) == -1){
            c = "Outgoing Links";
            a = h;
        }
        else if(h.match(/\/assets\//) && !h.match(/\.(jpe?g|pdf|ps|pptx|ppsx)$/i)){
            c = "Downloads";
            a = h.match(/\/assets\/(.*)/)[1];
        }
        if(c){
            _gaq.push(["_trackEvent",c,a,l]);
            /* Push secondary tracker if set */
            _gaq2 && _gaq.push(["b._trackEvent",c,a,l]);
            /* if target not set delay opening of window by 0.5s to allow tracking */
            if(!el.target || el.target.match(/^_(self|parent|top)$/i)){
                setTimeout(function(){
                    document.location.href = el.href;
                }.bind(el),500);
                /* Prevent standard click */
                event.preventDefault ? event.preventDefault() : event.returnValue = !1;
            }
        }

    }
}

var d = document;
d.addEventListener ? d.addEventListener("click",_gaLt,!1) : d.attachEvent && d.attachEvent("onclick",_gaLt);
</script>
</head>
<body>
<div id=wrapall>
  <div id=topwrap style="padding-left : 40px">
<h1>Iftach Haitner - <span style="font-size : 125%"> יפתח הייטנר</span> </h1>
<div   alt="" class="backup shadow2" id="iftach_pic"></div>
<p style="font-size : 110%"> I am a faculty member at the <a href="http://www.cs.tau.ac.il">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.
I am a part of the <a href="http://www.cs.tau.ac.il/~theory/">Theory of Computation Group</a> at TAU, and a member at the <a href="http://www.icore-algo.org.il/">Israeli
Center of Research Excellence in Algorithms (ICORE)</a> and the <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security</a>.<br><br>
My main research interests are Cryptography and Computational
Complexity.<br></p>


<span class=boxtop id=info>[Info]</span>
<span class=boxtop id=bio>[Short Bio]</span>
<span class=boxtop id=pro>[Professional Activity]</span>
<span class=boxtop id=teach>[Teaching]</span>  
<span class=boxtop id=edu>[School Activity]</span></br>
<span class=boxtop id=postdocs>[Call for Postdocs & Interns]</span>


<div class="info top">
<h2>Contact Information</h2>
Tel Aviv university, Schreiber Building, Office 020<br>
Phone:+972-3-6407996<br>
Fax: +972-3-6409373<br>
Email: [firstname] [dot] [lastname] [at] cs.tau.ac.il<br>
Mail: Iftach Haitner, Tel Aviv university, P.O.B. 39040, Ramat Aviv, Tel Aviv 69978, Israel <br>
 </div>

<div class="bio top">
<h2>Short Biography </h2>
I am a faculty  member of the <a href="http://www.cs.tau.ac.il">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.<br>
I am a member at the <a href="http://www.icore-algo.org.il/">Israeli
Center of Research Excellence in Algorithms (ICORE)</a> and the <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security</a>.<br>
Until July 2010, I was a postdoctoral researcher at <a href="http://research.microsoft.com/en-us/labs/newengland/">Microsoft
Research New England</a>. Prior to the time at Microsoft
Research, I did a six months postdoc at <a href="http://www.cs.haifa.ac.il/"><font>Department of
Computer Science, University of Haifa</font></a>, hosted by
<a href="http://cs.haifa.ac.il/%7Eronen/"> Ronen
shaltiel</a>.
I received my PhD in 2008 from the <a href="http://www.wisdom.weizmann.ac.il/">Faculty of
Mathematics and Computer Science, Weizmann Institute of Science</a>,  under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/">Omer
Reingold</a>. I got my Master's degree also
from the Weizmann Institute, under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Eoded/">Oded
Goldreich</a>, and did my undergraduate studies (Mathematics and
Computer Science) at <a href="http://www.tau.ac.il/">Tel-Aviv
university</a>.<br><br>


<b>Awards and Fellowships</b><br>
<ul>

<li> [2014] The annual fruits of the Raymond and Beverly Sackler Career Development Chair, awarded by the Faculty
of Exact Sciences, Tel Aviv University, in recognition of academic excellence. </li>
<li>[2011] One of the three winning papers of the 2011 SIAM Outstanding  Paper Prizes.<br>
The prizes are given for outstanding papers published in SIAM journals during the three years prior to the year of the award. </li>
<li> [2008] The John F. Kennedy Prize (awarded by the  Weizmann Institute) </li>
<li> [2008] Intel (Israel) award for outstanding Ph.D. students</li>
<li> [2008] Rothschild Fellowship for Post-Doctoral  Research (declined)</li>
<li> [2007] Otto Schwartz prize for excellent studies, PhD</li>
<li> [2007] Dean's List of Honour at the Weizmann Institute of Science</li>
<li> [2006] Best paper CRYPTO 2006</li>
<li> [2006] Best paper award ICALP 2006 track C</li>
</ul>
<br>


<b>Grants</b><br>
<ul>
<li>[2015-2020] European Research Council (ERC) Starting Grant  -- Individual research grant. </li>
<li>[2011-2015] Israel  Science Foundation (ISF) -- Individual research grant. </li>
<li>[2011-2015] Israel Science Foundation (ISF) -- Equipment for new faculty. </li>
<li>[2011-2015] Israel Science Foundation(ISF) -- Israeli Center of Research Excellence in Algorithms. </li>
<li>[2011-2015] US-Israel Binational Science Foundation
(BSF), with Salil Vadhan.</li>
</ul>

</div>



 <div class="pro top">
<h2>Professional Activity</h2>

<b>Program Committees</b><br>
<ul>

<li> <a href="http://www.easyconferences.eu/icalp2016">ICALP 2016  (Track A)</a></li>

 <li> <a href="http://www.iacr.org/workshops/tcc2014/">Theory of  Cryptography Conference (TCC) 2014</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2013/">CRYPTO 2013</a></li>
<li> <a href="http://computationalcomplexity.org/Archive/2013/cfp.html">Conference on Computational Complexity (CCC) 2013</a></li>
<li> <a href="http://www.iacr.org/workshops/tcc2012/">Theory  of Cryptography Conference (TCC) 2012</a></li>
<li> <a href="http://cist.korea.ac.kr/%7Easiacrypt2011/">Asiacrypt 2011</a> </li>
<li> <a href="http://ct-rsa2011.di.uoa.gr/CT-RSA_2011/Welcome___CT-RSA_2011.html">CT-RSA  2011</a></li>
<li> <a href="http://www.crypto.ethz.ch/tcc2010/">Theory  of Cryptography Conference (TCC) 2010</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2009/">CRYPTO  2009</a></li>
</ul>
<b>Seminars   and Workshops </b>
<UL>
<li>Co-organizer of the <a href="https://desertcrypt2015.workshop.org.il/">Second Desert Workshop in Cryptography 2016</a></li>

<li>Co-organizer of the <a href="http://intractability2013.workshop.org.il/">Modeling  Intractability workshop 2013</a></li>

 <li>Co-organizer  of the <a href="http://www.cs.tau.ac.il/cseminar/">Greater Tel Aviv Area Cryptography Seminar (GTACS)</a></li>

</UL>
<b>Teaching</b> (outside of TelAviv university)
<ul>
<li><a href="http://crypto.biu.ac.il/winterschool2014/">4th  Bar-Ilan Winter School on Cryptography</a></li>
<li> <a href="http://blackboxsummerschool.wordpress.com/">School on   Black-Box Impossibility Results  </a></li>
</ul>

<b>Other</b>
<ul>
<li>General co-chair of <a href="http://www.cs.tau.ac.il/conferences/tcc2016/">Theory of  Cryptography Conference (TCC) 2016-A</a></li>
</ul>

</div>

 <div class="teach top">
<h2> Teaching  </h2>
<ul>

    <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Info/Fall15/index.html"> Applications of Information Theory&nbsp; (Fall 15)</a></li>
	
    <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/ZK/Spring16.html"> Zero Knowledge Proofs (student seminar)&nbsp; (Spring 16)</a></li>

  <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/AvgHardness/Spring15.html"> Average-Case Hardness (student seminar)&nbsp; (Spring 15)</a></li>
  
  <li><a href="http://tau-cm2015b.wikidot.com/">Computational Model (Spring 15)</a></li>
  <li><a  href="Courses/FOC/Spring14/index.html" >Foundation  of Cryptography (Spring 14)</a></li>
</ul></div>

<div class="edu top">
<h2>School Activity</h2>
<ul>
<li><a href="http://www.cs.tau.ac.il/MSCX_program/mscx.htm">Excellence Program for Master Studies</a></li>
 </ul>
</div>

<div class="postdocs top">
<h2> Call for Postdocs and Interns</h2>
See the <a href="http://cpiis.cs.tau.ac.il/content/call-postdocs-interns">TAU crypto group call</a>
</div>



</div> <!--topwrap-->
<!-----------------publications---------------------------------------->


 <div id=wrapper >
 <h1 style="margin-left : 30px ; margin-top : 0px">Publications   <span style="font-size :12px ; font-weight : 400">(in Reverse Chronological Order)</span></h1>

<ul id=pub1>


<li>
<p>
Iftach Haitner and  <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a> and <a href="http://omrier.wix.com/eran-omri">Eran Omri</a>  and and  <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
<strong>Parallel Hashing via List Recoverability</strong>  <img src="new.png" class=update1><br>
<span class=abslide>[abstract]</span><br>
Crypto 2015  <a href="papers/CRHDomainExtension/CRH_Crypto.pdf">[pdf]</a><br>
</p>


<div class="box">
<p>
Motivated by the goal of constructing efficient hash functions, we investigate the possibility of hashing a long message by only making parallel,
non-adaptive calls to a hash function on short messages. Our main result is a simple construction of a collision-resistant hash function <span class=blu2>h:{0,1}<sup>k</sup> <td>&#8594;</td> {0,1}<sup>k</sup> </span> that makes a polynomial number of parallel calls to a \emph{random} function <span class=blu2> f:{0,1}<sup>k</sup> <td>&#8594;</td> {0,1}<sup>k</sup> </span>, for any polynomial <span class=blu2> n=n(k) </span>.  This should be compared with the traditional use of a Merkle hash tree, that  requires at least <span class=blu2> log(n/k)</span> rounds of calls to <span class=blu2>f</span>, and with a more complex construction of  <span class=blu1> Maurer and Tessaro (Crypto 2007)</span> that requires two rounds of calls to  <span class=blu2>f</span>. We also show that our hash function  <span class=blu2>h</span> satisfies a relaxed form of the notion of indifferentiability of  <span class=blu1> Maurer et al. (TCC 2004)</span> that suffices for implementing the Fiat-Shamir paradigm. As a corollary, we get sublinear-communication non-interactive arguments for NP that only make two rounds of calls to a small random oracle.

An attractive feature of our construction is that  <span class=blu2>h</span> can be implemented by boolean circuits that only contain parity gates in addition to the parallel calls to  <span class=blu2>f</span>. Thus, we get the first domain-extension scheme which is   <em>degree-preserving</em> in the sense that the algebraic degree of  <span class=blu2>h</span> over the binary field is equal to that of  <span class=blu2>f</span>

Our construction makes use of <em>list-recoverable codes</em>, a generalization of list-decodable codes that is closely related to the notion of randomness condensers. We show that list-recoverable codes are necessary for any construction of this type.
</p>
</div>



<li>
<p>
<a href="http://u.cs.biu.ac.il/~cohenrb/">Ran Cohen</a> and Iftach Haitner and  <a href="http://omrier.wix.com/eran-omri">Eran Omri</a>  and Lior Rotem<br>
<strong>Characterization of Secure Multiparty Computation Without Broadcast </strong>  <img src="new.png" class=update1><br>
<span class=abslide>[abstract]</span><br>
TCC 2016-A <a  href="http://link.springer.com/chapter/10.1007/978-3-662-49096-9_25">[link]</a><br>
Draft of full version <a href="papers/NoBroadcastCoin/MPCNoBroadcast.pdf">[pdf]</a> 
</p>


<div class="box">
<p>
 A major challenge in the study of cryptography is characterizing the necessary and sufficient assumptions required to carry out a given cryptographic task. The focus of this work is the necessity of a broadcast channel for securely computing symmetric functionalities (where all the parties receive the same output) when one third of the parties, or more, might be corrupted. Assuming all parties are connected via a peer-to-peer network, but no broadcast channel (nor a secure setup phase) is available, we prove the following characterization:<br>

 <ul>
 <li>
    A symmetric <span class=blu2>n</span>-party functionality can be securely computed facing <span class=blu2> n/3 &#8804 t &#60 n/2</span>  corruptions (i.e., honest majority), if and only if it is <em><span class=blu2>(n-2t)</span>-dominated</em> a functionality is <span class=blu2>k</span>-dominated, if <em>any</em> <span class=blu2>k</span>-size subset of its input variables can be set to <em>determine</em> its output.
 </li> 	
  	
	
<li>	
    Assuming the existence of one-way functions, a symmetric <span class=blu2>n</span>-party functionality can be securely computed facing <br><span class=blu2>t &#8805 n/2</span> corruptions (i.e., no honest majority), if and only if it is <span class=blu2>1</span>-dominated and can be securely computed with broadcast.
 </li> 	
</ul>
  It follows that, in case a third of the parties might be corrupted, broadcast is necessary for securely computing non-dominated functionalities (in which ``small'' subsets of the inputs cannot determine the output), including, as interesting special cases, the Boolean XOR and coin-flipping functionalities.
</p>
</div>
</li>

<li>
<p>
<a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay Berman</a> and Iftach Haitner and  <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>Coin Flipping of Any Constant Bias Implies One-Way Functions </strong> <br>
<span class=abslide>[abstract]</span>&nbsp<a href="papers/TightCF/TightCoinFlipping_full.ppsx">[slides]</a><br>
STOC 2014 <a href="papers/TightCF/TightCoingFlipping_CR.pdf">[pdf]</a><br>
Draft of full version <a href="papers/TightCF/TCoingFlip_F.pdf">[pdf]</a>  <img src="up.png" class=update1>
</p>


<div class="box">
<p>
We show that the existence of a coin-flipping protocol safe against any non-trivial constant bias (e.g., <span class=blu2>.499</span>), implies the
existence of one way functions. This improves upon a recent result of <span class=blu1>Haitner and Omri [FOCS ’11]</span> ,
who proved this implication for protocols with bias <span class=blu2>&radic;<span style="text-decoration:overline;">2</span>− <sup>1</sup>⁄<sub>2</sub>&nbsp;~.207</span>. Unlike the result of
Haitner and Omri, our result holds also for <em>weak</em> coin-flipping protocols.
</p>
</div>
</li>



<li>
Iftach Haitner and Eliad Tsfadia <br>
<strong>An Almost-Optimally Fair Three-Party Coin-Flipping Protocol</strong><br>
<span class=abslide>[abstract]</span> <a href="papers/3PartyCF/3Party-full.ppsx">[slides]</a> <br>
STOC 2014 <a href="papers/3PartyCF/QuasiOptimalCF_CR.pdf">[pdf]</a><br>
Draft of dull version <a href="papers/3PartyCF/QuasiOptimalCF_Full.pdf">[pdf]</a> <img src="up.png" class=update1>



<div class="box">
<p>
In a multiparty, fair coin-flipping protocol, the parties output a common (close to) unbiased bit, even when some  corrupted parties try to bias the output.
<span class=blu1> Cleve [STOC 1986] </span> has shown that in the case of dishonest
majority (i.e., at least half of the parties can be corrupted), the  corrupted parties can bias the honest parties common output bit
by  <span class=blu2> &Omega;(1/m)</span>, in any m-round, coin-flipping protocol. For more than two decades, however, the best known
coin-flipping protocols had bias <span class=blu2> &Theta;(&radic;<span style="text-decoration:overline;">t</span>)</span> 
against dishonest majority, where <span class=blu2>t</span> is the number of
corrupted parties. This was changed by a recent breakthrough result of <span class=blu1> Moran et al. [TCC 2009]</span>,
who constructed an <span class=blu2>m</span>-round,
two-party coin-flipping protocol with optimal bias <span class=blu2>&Theta;(1/m)</span>. Where in a
subsequent work, <span class=blu1> Beimel et al. [Crypto 2010]</span> extended this result for the multiparty
case, in which less than  <span class=blu2> <sup>2</sup>⁄<sub>3</sub></span> of case, in which less than  <span class=blu2> <sup>2</sup>⁄<sub>3</sub></span> of
the parties can be corrupted. More specifically, for any <span class=blu2> t &lt; <sup>2</sup>⁄<sub>3</sub>
· k </span>, they presented an <span class=blu2>m</span>-round, <span class=blu2>k</span>-party
protocol, with bias <span class=blu2>&Theta;( 2<sup>2t−k</sup>/m)</span> against (up to) <span class=blu2>t</span>
corrupted parties. Still for the case  <span class=blu2> <sup>2</sup>⁄<sub>3</sub></span>
(or more) corrupted parties, the best known protocol had bias <span class=blu2> &Theta;(t/&radic;<span style="text-decoration:overline;">m</span>)</span>. In particular,
this was the state of affairs for the natural three-party case (against
two corrupted parties).<br>
<br>
We make a step towards eliminating the above gap, presenting an m-round, three-party,
coin-flipping protocol, with bias <span class=blu2> O(log 3 m)/m</span>. Our approach (which we also apply for the two-party case), does not
follow the “threshold round” paradigm used in the work of Moran et al. and Beimel et al.,
but rather is a takeoff of the majority protocol of Cleve (used to obtain the <span class=blu2> &Theta;(&radic;<span style="text-decoration:overline;">t</span>)</span>-bias protocol,
mentioned above).
</p>
</div>
</li>


<li>
<p><a name="HHRSJoint"></a> 
Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>
and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<strong>Finding Collisions in Interactive Protocols — Tight Lower Bounds on the Round Complexity and Communication Complexityof Statistically Hiding Commitments </strong>
<br>
<span class=abslide>[abstract]</span><br>
SIAM Journal of Computing 2015 <a  href="http://epubs.siam.org/doi/abs/10.1137/130938438">[link]</a><br>

Draft of full version <a href="papers/FindingCollisions/FindingCollisions_Joint.pdf"> [pdf]</a>  <img src="up.png" class=update1>
</p>


<div class="box" >
<p>
We study the round complexity and communication complexity of various cryptographic protocols. We give tight lower bounds on the 
round complexity and communication complexity of any fully black-box reduction of a statistically hiding commitment scheme from one-way
permutations, and from trapdoor permutations. As a corollary, we derive  similar tight lower bounds for several other cryptographic protocols,
such as single-server private information retrieval, interactive hashing, and oblivious transfer that guarantees statistical security
for one of the parties. Our techniques extend the collision-finding oracle due to <span class=blu1>Simon [EUROCRYPT 98] </span> to the setting of interactive protocols, 
and the reconstruction paradigm of

In their seminal work, Impagliazzo and Rudich (STOC’89) showed that no key-agreement protocol exists in the random-oracle model, yielding that key agreement cannot be black-box reduced to one-way functions. In this work, we generalize their result, showing that, to a large extent, no-private-input, semi-honest, two-party functionalities that can be securely implemented in the random oracle model can be securely implemented information theoretically (where parties are assumed to be all powerful, and no oracle is given). Using a recent information-theoretic impossibility result by McGregor et al. (FOCS’10), our result yields that certain functionalities (e.g. inner product) cannot be computed both in an accurately and in a differentially private manner in the random oracle model, implying that protocols for computing these functionalities cannot be black-box reduced to the existence of one-way functions.
Gennaro and Trevisan [FOCS 00]</span>.
</p>
</div>
</li>



<li>
<p><a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay Berman</a> and Iftach Haitner and 
<a href="https://sites.google.com/site/ilankomhomepage/"> Ilan Komargodski</a> and <a href="http://www.wisdom.weizmann.ac.il/%7Enaor/">Moni Naor</a><br>
<strong>Hardness Preserving Reductions via Cuckoo Hashing </strong><br> 
<span class=abslide>[abstract]</span><br>
TCC 2013 <a href="papers/Cuckoo/Cuckoo_TCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/Cuckoo/Cuckoo%20.pdf">[pdf]</a></p>

<div class="box">
A common method for increasing the usability and uplifting the security of pseudorandom function families (PRFs) is to “hash” the inputs into a
smaller domain before applying the PRF. This approach, known as “Levin’s trick”, is used to achieve “PRF domain extension” (using a short, e.g., fixed, input length PRF to get a
variable-length PRF), and more recently to transform non-adaptive PRFs to adaptive ones. Such reductions, however, are
vulnerable to a “birthday attack”: after <span class=blu2> &Theta;(&radic;<span style="text-decoration:overline;">|U|</span>)</span> 
queries to the resulting PRF, where <span class=blu2>U</span> being the hash function range, a collision 
(i.e., two distinct inputs have the same hash value) happens with high probability. As a consequence, the resulting PRF is insecure
against an attacker making this number of queries.<br>

In this work we show how to go beyond the birthday attack barrier, by
replacing the above simple hashing approach with a variant of <strong>cuckoo
hashing</strong> — a hashing paradigm typically used for resolving hash collisions in a table, by using two hash functions
and two tables and cleverly assigning each element into one of the two tables. We use this approach to obtain:<br>
(i) A domain extension method that requires <strong>just two calls</strong> to the original PRF, can withstand as many queries
as the original domain size and has a distinguishing probability that
is exponentially small in the non cryptographic work.<br>
(ii) A <strong>security-preserving</strong> reduction from non-adaptive to adaptive PRFs.
</div>
</li>

<li>
Iftach Haitner and <a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a> and <a href="http://u.cs.biu.ac.il/%7Ezarosih/">Hila Zarosim</a><br>
<strong>Limits on the Usefulness of Random Oracles</strong> <br>
<span class=abslide>[abstract]</span><br>
Journal of Cryptology 2014  <a  href="http://link.springer.com/article/10.1007/s00145-014-9194-9?sa_campaign=email/event/articleAuthor/onlineFirst">[link]</a><br>
TCC 2013 <a href="papers/PowerofRO1/PowerOfRO_TCC.pdf">[pdf]</a><br>
Draft of full version  <a href="papers/PowerofRO1/PowerOfRO.pdf">[pdf]</a></p>
<div class="box">
In their seminal work, <span class=blu1>Impagliazzo and Rudich [STOC’89]</span> showed that no key-agreement protocol exists in the random-oracle model,
yielding that key agreement cannot be black-box reduced to one-way functions. 
In this work, we generalize their result, showing that, to a large extent, no-private-input, semi-honest, two-party functionalities that can
be securely implemented in the random oracle model can be securely implemented information theoretically (where parties are assumed to be all powerful, 
and no oracle is given). Using a recent information-theoretic impossibility result by <span class=blu1> McGregor et al. [FOCS’10]</span>, 
our result yields that certain functionalities (e.g. inner product) cannot be computed both in an accurately and in a differentially private manner in the 
random oracle model,  implying that protocols for computing these functionalities cannot be black-box reduced to the existence of one-way functions.
</div>
</li>

<li>
<p>
 <a href="http://www.cs.tau.ac.il/%7Eitayberm/">Itay Berman</a> and Iftach Haitner<br>
<strong>From Non-Adaptive to Adaptive Pseudorandom Functions</strong><br>
<span class=abslide>[abstract]</span><br>
Journal of Cryptology 2013  <a  href="http://link.springer.com/article/10.1007/s00145-013-9169-2">[link]</a><br>
TCC 2012 <a href="papers/AdaptivePRF/AdaptivePRF_TCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/AdaptivePRF/AdaptivePRF.pdf">[pdf]</a>
</p>

<div class="box"  >
Unlike the standard notion of pseudorandom functions (PRF), a <strong> non-adaptive</strong> PRF 
is only required to be indistinguishable from a random function in the eyes of a <strong>non-adaptive</strong>
distinguisher (i.e., one that prepares its oracle calls in advance). A recent line of research has studied the possibility of a <strong>direct</strong>
construction of adaptive PRFs from non-adaptive ones, where direct means that the constructed adaptive PRF uses only few (ideally,
constant number of) calls to the underlying non-adaptive PRF. Unfortunately, this study has only yielded negative results, showing
that ``natural" such constructions are unlikely to exist (e.g., <span class=blu1> Myers [EUROCRYPT '04], Pietrzak [CRYPTO '05, EUROCRYPT '06]</span>).<br>
<br>
We give an affirmative answer to the above question, presenting a direct construction of adaptive PRFs from non-adaptive ones. The
suggested construction is extremely simple, a composition of the non-adaptive PRF with an appropriate pairwise independent hash
function.
</div>
</li>

<li>
<p>
Iftach Haitner and <a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a><br>
<strong>Coin Flipping with Constant Bias ImpliesOne-Way Functions</strong><br>
<span class=abslide>[abstract]</span>&nbsp <a href="papers/CoinFlipping/Seminar.pptx">[slides]</a><br>
SIAM Journal of Computing 2013   <a  href="http://epubs.siam.org/doi/abs/10.1137/120887631">[link]</a> <br>
FOCS 2011 <a href="papers/CoinFlipping/FOCS.pptx">[pdf]</a><br>
Draft of full version <a href="papers/CoinFlipping/CoinFlippingtoOWF.pdf">[pdf]</a></p>

<div class="box">
<p>
It is well known (c.f., <span class=blu1> Impagliazzo and Luby [FOCS '89]</span>) that the existence
of almost all ``interesting" cryptographic applications, i.e., ones that cannot hold information theoretically, implies one-way functions.
An important exception where the above implication is not known, however, is the case of coin-flipping protocols. Such protocols allow
honest parties to mutually flip an unbiased coin, while guaranteeing that even a cheating (efficient) party cannot bias the output of the
protocol by much. While Impagliazzo and Luby proved that coin-flipping protocols that are safe against negligible bias do imply one-way
functions, and, very recently, <span class=blu1> Maji, Prabhakaran, and Sahai [FOCS '10]</span>
proved the same for constant-round protocols (with any non-trivial bias). For the general case, however, no such implication was known.
<br>
We make progress towards answering the above fundamental question, showing that (strong) coin-flipping protocols safe against a constant
bias (concretely,<span class=blu2>&radic;<span style="text-decoration:overline;">2</span>− <sup>1</sup>⁄<sub>2</sub>&nbsp;~.207</span>) imply one-way functions.
</p>

</div>
</li>


<li>
<p> 
<a href="http://www.cs.nyu.edu/%7Edodis/">Yevgeniy Dodis</a>, Iftach Haitner and <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>On the Instantiability of Hash-and-Sign RSA Signatures</strong><br> 
<span class=abslide>[abstract]</span> <a href="papers/FullDomainHash/seminar.pptx">[slides]</a><br>
TCC 2012 <a href="papers/FullDomainHash/FDH_TCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/FullDomainHash/FDH.pdf">[pdf]</a>
</p>

<div class="box"  >
<p> 
The hash-and-sign RSA signature is one of the most elegant and well known signatures schemes, extensively used in a wide variety of cryptographic
applications. Unfortunately, the only existing analysis of this popular signature scheme is in the random oracle model, where the resulting
idealized signature is known as the <em>RSA Full Domain Hash</em> signature scheme (RSA-FDH). In fact, prior work has shown several
``uninstantiability'' results for various abstractions of RSA-FDH, where the RSA function was replaced by a family of trapdoor random
permutations, or the hash function instantiating the random oracle could not be keyed. These abstractions, however, do not allow the
reduction and the hash function instantiation to use the algebraic properties of RSA function, such as the multiplicative group structure
of <span class=blu2>Z<sub>n</sub>*</span>. In contrast, the multiplicative property of
the RSA function is critically used in many standard model analyses of various RSA-based schemes.<br>

Motivated by closing this gap, we consider the setting where the RSA function representation is generic (i.e., black-box) <strong>but
multiplicative</strong>, whereas the hash function itself is in the standard model, and can be keyed and exploit the multiplicative properties of
the RSA function. This setting abstracts all known techniques for designing provably secure RSA-based signatures in the standard model, and aims to address
the main limitations of prior uninstantiability results. Unfortunately, we show that it is still impossible to reduce the
security of RSA-FDH to any natural assumption even in our model. Thus, our result suggests that in order to prove the security of a given instantiation
of RSA-FDH, one should use a non-black box security proof, or use specific properties of the RSA group
that are not captured by its multiplicative structure alone.<br>

We complement our negative result with a positive result, showing that the RSA-FDH signatures <strong>can</strong> be proven
secure under the <strong>standard</strong> RSA assumption, provided that the number of signing queries is <strong>a-priori bounded</strong>.
</p> 
</div>
</li>


<li>
<p><a name="BBMPC"></a> 
Iftach Haitner, <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a>, <a href="http://www.cs.technion.ac.il/%7Eeyalk/">Eyal
Kushilevitz</a>, <a href="http://u.cs.biu.ac.il/%7Elindell//">Yehuda Lindell</a> and <a href="http://www.cs.technion.ac.il/%7Eerez/">Erez Petrank</a><br>
<strong>Black-Box Constructions of Protocols for Secure Computation</strong><br>
<span class=abslide>[abstract]</span><br>
SIAM Journal of Computing 2011 <a  href="http://epubs.siam.org/doi/abs/10.1137/080721820">[link]</a><br>
Draft of full version <a href="papers/BlackBoxMPC/black-box-mpc.pdf">[pdf]</a>
</p>

<div class="box" >
<p>
It is well known that secure computation without an honest majority requires computational assumptions. An interesting question that
therefore arises relates to the way such computational assumptions are used. Specifically, can the secure protocol use the underlying
primitive (e.g., a one-way trapdoor permutation) in a black-box way, treating it as an oracle, or must it be non-black-box (by referring to
the code that computes the primitive)? <br>
Despite the fact that many general constructions of cryptographic
schemes refer to the underlying primitive in a black-box way only,
there are some constructions that are inherently nonblack-box. Indeed,
all known constructions of protocols for general secure computation
that are secure in the presence of a malicious adversary and without an
honest majority use the underlying primitive in a nonblack-box way
(requiring to prove in zero-knowledge statements that relate to the
primitive).<br>
In this paper, we study whether such nonblack-box use is essential. We
answer this question in the negative. Concretely, we present a fully
black-box reduction from oblivious transfer with security against
malicious parties to oblivious transfer with security against
semi-honest parties. As a corollary, we get the first constructions of
general multiparty protocols (with security against malicious
adversaries and without an honest majority) which only make a black-box
use of semi-honest oblivious transfer, or alternatively a black-box use
of lower-level primitives such as enhanced trapdoor permutations or
homomorphic encryption. 
</p>
</div>
</li>


<li>
<p>
Iftach Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a> and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
<b>Efficiency Improvements in Constructing Pseudorandom Generators from One-way Functions</b><br>
<span class=abslide>[abstract]</span> <a href="papers/HillRevisted/HillRevisted_Full.pptx">[slides]</a> <br><br>

SIAM Journal of Computing 2013    <a  href="http://epubs.siam.org/doi/abs/10.1137/100814421">[link]</a><br>
Annual ACM Symposium on Theory of Computing (STOC), 2010  <a href="papers/HillRevisted/HillRevisted_STOC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/HillRevisted/HillRevisted_Full.pdf">[pdf]</a>
</p>

<div class="box" >
<p>
We give a new construction of pseudorandom generators from any one-way
function. The construction achieves better parameters and is simpler
than that given in the seminal work of <span class=blu1> Håstad, Impagliazzo, Levin and Luby [SICOMP '99]</span>. 
The key to our construction is a new notion of <strong>next-block pseudoentropy</strong>, which is inspired by the notion of
``inaccessible entropy'' recently introduced in <span class=blu1> Haitner, Reingold,Vadhan and Wee [STOC '09]</span>. An additional advantage over all previous
constructions is that our pseudorandom generators are highly parallelizable and invoke the one-way function in a non-adaptive
manner. Using <span class=blu1>Applebaum, Ishai and Kushilevitz [SICOMP '06]</span>, this implies the existence of pseudorandom generators in 
<span class=blu2>NC<sup>0</sup></span> based on the existence of one-way functions in <span class=blu2>NC<sup>1</sup></span>.
</p>
</div>
</li>

<li>
<p>
<a href="http://www.cs.princeton.edu/%7Eboaz/">Boaz Barak</a>, Iftach Haitner, <a href="http://homepages.cwi.nl/%7Ehofheinz/">Dennis Hofheinz</a>
and <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a><br>
<strong>Bounded Key-Dependent Message Security</strong><br>
<span class=abslide>[abstract]</span><br>
Advances in Cryptology - Eurocrypt, 2010 <a href="papers/BoundedKDM/boundedkdm_EuroCrypt.pdf">[pdf]</a><br>
Draft of full version <a href="papers/BoundedKDM/boundedkdm.pdf">[pdf]</a>
</p>


<div class="box" >
<p>
We construct the first public-key encryption scheme that is proven secure
(in the standard model, under standard assumptions) even when the attacker gets access to encryptions of arbitrary efficient functions of the secret key.
Specifically, under either the DDH or LWE assumption, for every polynomials <span class=blu2>L</span> and <span class=blu2>N</span> we obtain a
public-key encryption scheme that resists key-dependent message (KDM) attacks for up to <span class=blu2>N(k)</span>
public keys and functions <strong>circuit size</strong> up to <span class=blu2>L(k)</span>, where <span class=blu2>k</span> denotes the size of the secret
key. We call such a scheme <strong>bounded KDM secure</strong>. Moreover, we show that our scheme suffices for
one of the important applications of KDM security: ability to securely instantiate symbolic protocols with
axiomatic proofs of security.<br>

We also observe that any fully homomorphic encryption scheme which
additionally enjoys circular security and circuit privacy is <strong>fully KDM secure</strong> in the sense that the encryption and
decryption algorithms can be independent of the polynomials <span class=blu2>L</span> and <span class=blu2>N</span> as
above. Thus, the recent fully homomorphic encryption scheme of <span class=blu1>Gentry [STOC 2009]</span> is fully KDM
secure under certain non-standard hardness assumptions. Previous works obtained either full KDM security in the random oracle
model (<span class=blu1> Black et al. [SAC 2002]</span>) or security with respect to a very restricted
class of functions (e.g., clique/circular security and affine functions, <span class=blu1> Boneh et al. [CRYPTO 2008]</span> and 
<span class=blu1> Applebaum et al. [CRYPTO 2009]</span>.<br>
Our main result is based on a combination of the circular-secure
encryption scheme of either Boneh et al. <strong>or</strong> Applebaum et al. with
Yao's garbled circuit construction.<br>
Finally, we extend the impossibility result of <span class=blu1> Haitner and Holenstein [TCC 2009]</span>, showing that it
is impossible to prove KDM security against a family of query functions that contains exponentially hard pseudorandom functions, 
using only <strong>black-box</strong> access to the query function and the adversary attacking the scheme. This proves that the non-black-box
usage of the query function in our proof of security makes to the KDM query function is <strong>inherent</strong>.
</p>
</div>
</li>

<li>
<p>
Iftach Haitner, <a href="http://research.microsoft.com/users/thomahol/">Thomas Holenstein</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a>, <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
<b>Universal One-Way Hash Functions via Inaccessible Entropy </b><br>
<span class=abslide>[abstract]</span><br>
Advances in Cryptology - Eurocrypt, 2010 <a href="papers/RompelRevisted/RompelRevisited-EurocryptCamera.pdf">[pdf]</a><br>
Draft of full version <a href="papers/RompelRevisted/RompelRevisited-eprint.pdf">[pdf]</a>
</p>


<div class="box">
<p>
This paper revisits the construction of Universally One-Way Hash Functions (UOWHFs) from any one-way function due to <span class=blu1> Rompel [STOC 1990}</span>.
We give a simpler construction of UOWHFs which also obtains better efficiency and security. The construction exploits a strong connection to the recently
introduced notion of <strong>inaccessible entropy</strong> <span class=blu1> Haitner et
al. [STOC 2009]</span>. With this perspective, we observe that a small tweak of
any one-way function <span class=blu2> f</span> is already a weak form of a UOWHF: Consider
<span class=blu2> F(x,i)</span> that outputs the <span class=blu2>i</span>-bit long
prefix of <span class=blu2>f(x)</span>. If <span class=blu2>F</span> were a UOWHF then given a
random <span class=blu2>x</span> and i it would be hard to come up with <span class=blu2>x' ≠ x</span> such
that <span class=blu2>F(x,i)=F(x',i)</span>. While this may not be the case, we show (rather easily) that it is hard
to sample <span class=blu2>x'</span> with almost full entropy among all the possible such values of <span class=blu2>x'</span>. The rest of our construction
simply amplifies and exploits this basic property.<br>
With this and other recent works we have that the constructions of
three fundamental cryptographic primitives (Pseudorandom Generators,
Statistically Hiding Commitments and UOWHFs) out of one-way functions
are to a large extent unified. In particular, all three constructions
rely on and manipulate computational notions of entropy in similar
ways. Pseudorandom Generators rely on the well-established notion of
pseudoentropy, whereas Statistically Hiding Commitments and UOWHFs rely
on the newer notion of inaccessible entropy.
</p>
</div>
</li>


<li>
<p>
Iftach Haitner,  <a href="http://www.cs.princeton.edu/%7Emohammad/">Mohammad Mahmoody</a> and <a href="http://www.cs.princeton.edu/%7Edxiao/"> David Xiao</a><br>
<strong>New Sampling Protocol and Applications to Basing Cryptographic Primitives on the Hardness of NP</strong><br>
<span class=abslide>[abstract]</span> <br>
IEEE Conference on Computational Complexity (CCC), 2010 <a href="papers/SampleWithSize/SampleWithSize_CCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/SampleWithSize/SampleWithSize.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
We investigate the question of what languages can be decided efficiently with the help of a recursive collision-finding oracle. Such an oracle can be used to break
collision-resistant hash functions or, more generally, statistically hiding commitments. The
oracle we consider <span class=blu2>Sam<sub>d,</sub></span> where <span class=blu2>d</span> is the
recursion depth, is based on the identically-named oracle defined in the work of
<span class=blu1>Haitner et al. (FOCS '07)</span>. Our main result is a constant-round public-coin protocol <span class=blu2>AM-Sam</span>
that allows an efficient verifier to emulate a <span class=blu2>Sam<sub>d</sub></span>
oracle for any constant depth <span class=blu2>d = O(1)</span> with the help of a <span class=blu2>BPP<sup>NP</sup></span>
prover. <span class=blu2> AM-Sam</span> allows us to conclude that if <span class=blu2>L</span>
is decidable by a <span class=blu2>k</span>-adaptive randomized oracle algorithm with access to a <span class=blu2>Sam<sub>O(1)</sub></span>
oracle, then <span class=blu2>L∈AM[k]∩coAM[k]</span>.<br>

The above yields the following corollary: assume there exists an
<span class=blu2>O(1)</span>-adaptive reduction that bases constant-round statistically hiding commitment on NP-hardness,
then <span class=blu2> NP ⊆ coAM</span> and the polynomial hierarchy collapses. The same result holds for any
primitive that can be broken by <span class=blu2>Sam<sub>O(1)</sub></span> including collision-resistant hash functions and <span class=blu2>O(1)</span>-round 
oblivious transfer where security holds statistically for one of the parties. We also obtain
non-trivial (though weaker) consequences for <span class=blu2>k</span>-adaptive reductions for any <span class=blu2>k = poly(n)</span>.
Prior to our work, most results in this research direction either applied only to non-adaptive reductions (<span class=blu1>Bogdanov and Trevisan
[SIAM J. of Comp. '06]</span>) or to primitives with special regularity properties (<span class=blu1>Brassard [FOCS '79], Akavia et al. [FOCS '06]</span>.<br>
The main technical tool we use to prove the above is a new constant-round public-coin protocol (SampleWithSize) 
that we believe may be interesting in its own right, and that guarantees the following. Given an efficient function 
<span class=blu2>f</span> on <span class=blu2>n</span>
bits, let <span class=blu2>D</span> be the output distribution <span class=blu2>D = f(U<sub>n</sub>)</span>,
then SampleWithSize allows an efficient verifier Arthur to use an all-powerful prover Merlin's help to sample a random <span class=blu2>y ← D></span> 
along with a good multiplicative approximation of the probability <span class=blu2>p<sub>y</sub>
= Pr<sub>y' ← D</sub>[y' = y]</span>. The crucial feature of SampleWithSize
is that it extends even to distributions of the form <span class=blu2>D = f(U<sub>S</sub>)</span>,
where <span class=blu2>U<sub>S</sub></span>
is the uniform distribution on an efficiently decidable subset <span class=blu2> S ⊆{0.1}<sup>n</sup></span>
(such <span class=blu2>D></span> are called <em>efficiently samplable with post-selection</em>), as long 
as the verifier is also given a good approximation of the value <span class=blu2>|S|</span>.</p>
</p>
</div>
</li>

<li>
<p>
Iftach Haitner<br>
<strong>A Parallel Repetition Theorem for Any Interactive Argument </strong><br>
<span class=abslide>[abstract]</span> <a href="papers/ArgumentPR/Seminar.pptx">[slides]</a> <br>
SIAM Journal of Computing 2013   <a  href="http://epubs.siam.org/doi/abs/10.1137/100810630">[link]</a><br>
IEEE Symposium on Foundations of Computer Science (FOCS), 2009<br>
Draft of full version <a href="papers/ArgumentPR/ArgumentPR.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
The question whether or not parallel repetition reduces the soundness error is a fundamental question in the theory of protocols. 
While parallel repetition reduces (at an exponential rate) the error in interactive proofs and (at a weak exponential rate) in special cases of interactive
arguments (e.g., 3-message protocols - <span class=blu1>Bellare, Impagliazzo and Naor [FOCS '97]</span>, and 
public-coin protocols - <span class=blu1>Håstad, Pass, Pietrzak and
WikstrÄom [TCC '10])</span>, Bellare et. al gave example of interactive arguments for which parallel repetition does not reduce the soundness
error at <strong>all</strong>.<br>

We show that by slightly modifying  <em>any</em> interactive argument, in a way that preserves its completeness and only
slightly deteriorates its soundness, we get a protocol for which parallel repetition does reduce the error at a weak exponential rate.
In this modified version, the verifier flips at the beginning of each round an <span class=blu2>(1 - (1/4m), 1/4m)</span> biased
coin (i.e., <span class=blu2>1</span> is tossed with probability <span class=blu2>1/4m</span>), where <span class=blu2>m</span> is the round complexity of the
(original) protocol. If the coin is one, the verifier halts the interaction and accepts, otherwise it sends the same message that the
original verifier would. At the end of the protocol (if reached), the
verifier accepts if and only if the original verifier would.
</p>
</div>
</li>

<li>
<p><a name="HONRV"></a>
Iftach Haitner, Minh-Huyen Nguyen, Shien Jin Ong, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">OmercReingold</a> and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
<strong>Statistically Hiding Commitments and Statistical Zero-Knowledge Arguments from Any One-Way Function</strong> <br>
<span class=abslide>[abstract]</span>  <br>
SIAM Journal of Computing 2009  <a  href="http://epubs.siam.org/doi/abs/10.1137/080725404">[link]</a><br>
Draft of full version  <a href="papers/HNORV/HNORV-sicomp.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
We give a construction of statistically hiding commitment schemes (those in which the hiding property holds against even computationally unbounded adversaries) 
under the minimal complexity assumption that one-way functions exist. 
Consequently, one-way functions suffice to give statistical zero-knowledge arguments for any NP statement (whereby even a computationally 
unbounded adversarial verifier learns nothing other than the fact that the assertion being proven is true, and no polynomial-time adversarial
prover can convince the verifier of a false statement). These results resolve an open question posed by <span class=blu1> Naor et al. [J. Cryptology 98]</span>.
</p>

</div>

</li>



<li>
<p>
Iftach
Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>,
<a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
 <b>Inaccessible Entropy</b><br>
<span class=abslide>[abstract]</span> <a href="papers/AccessibleEntropy/AccEntSemniar.pptx">[slides]</a> 
<a href="http://intractability.princeton.edu/videos/stream/videoplay.html?videofile=cs/IW2009-500kb/Iftach%20Haitner.mp4">[video (appx. 1 hour)]</a><br>
 Annual ACM Symposium on Theory of Computing (STOC), 2009  <a href="papers/AccessibleEntropy/AE-stoc.pdf">[pdf]</a><br>
Draft of full version <a href="papers/AccessibleEntropy/AccessibleEntropy_full.pdf">[pdf]</a>
</p>


<div class="box">
<p>
We put
forth a new computational notion of entropy, which measures the (in)feasibility of sampling high entropy strings that are consistent
with a given protocol. Specifically, we say that the <span class=blu1> i</span>’th round of a protocol <span class=blu1> (A,B)</span> has <em>accessible
entropy</em> at most <span class=blu1>k</span>, if no polynomial-time strategy <span class=blu1>A*</span> can
generate messages for <span class=blu1>A></span> such that the entropy of its message in the <span class=blu1>i</span>’th round has entropy
greater than <span class=blu1>k</span> when conditioned both on prior messages of the protocol and on prior coin tosses of <span class=blu1> A*</span>. 
As applications of thisnotion, we
<ul>
<li>Give a much simpler and more efficient construction of statistically hiding
commitment schemes from arbitrary one-way functions.
</li>
<li>Prove that constant-round statistically hiding
commitments are necessary for constructing constant-round zero-knowledge proof systems for NP that 
remain secure under parallel composition (assuming the existence of
one-way functions).</li>
</ul>
</p>
</div>
</li>

<li>
<p>Iftach Haitner,   <a href="http://www.eecs.harvard.edu/%7Ealon/">Alon Rosen</a> and  <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
 b>On the (Im)Possibility of Arthur-Merlin Witness Hiding Protocols</b><br>
<span class=abslide>[abstract]</span> <a href="papers/WitnessHiding/WitnessHidingTCC.ppsx">[slides]</a>]<br>
Theory of Cryptography Conference (TCC), 2009 <a href="papers/WitnessHiding/WitnessHidingLB.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
The concept of <em>witness-hiding</em> suggested by <span class=blu1> Feige and Shamir [STOC 90]</span> is a natural relaxation of zero-knowledge. In this paper we
identify languages and distributions for which many known constant-round
public-coin protocols with negligible soundness cannot be shown to witness-hiding using
black-box techniques. In particular, our results imply that it is impossible to prove that
parallel repetition of 3-Colorability or Hamiltonicity is witness-hiding for distributions that support instances with exactly one witness, if the
proof of security is by a black-box reduction that is <em>independent</em> of the choice of the commitment scheme used in the protocol. This lower bound
conceptually matches an upper bound of Feige and Shamir that uses such a black-box reduction to show that parallel repetition of 3-Colorability
or Hamiltonicity <em>is</em> witness-hiding for distributions with ``two independent witnesses.<br>
We also consider black-box reductions for 3-Colorability or Hamiltonicity that <em>depend</em> on a specific
implementation of the commitment scheme. While we cannot rule out such reductions completely, we show that
``natural reductions" cannot bypass the limitations above.<br>
<br>
Our proofs use techniques developed by <span class=blu1>Goldreich and Krawczyk [ICALP  90]</span> for the
case of zero knowledge. The setup of witness-hiding, however, presents new technical and
conceptual difficulties that do not come up in the setup of zero-knowledge. The
high level idea is that if a black-box reduction establishes the witness-hiding
property for a protocol that is also a proof of knowledge, then this latter
property can be used ``against the reduction" to find witnesses unconditionally.
</p>
</div>
</li>


<li>
<p>
Iftach Haitner and <a href="http://research.microsoft.com/users/thomahol/">Thomas Holenstein</a><br>
<b>On the (Im)Possibility of Key Dependent Encryption</b><br>
<span class=abslide>[abstract]</span> <a href="papers/AccessibleEntropy/AccEntSemniar_f.pptx">[slides]</a> <br>
Theory of Cryptography Conference (TCC), 2009  <a href="papers/KDI/KDI-TCC_CR.pdf">[pdf]</a><br>
Draft of full version <a href="papers/KDI/KDI-full.pdf">[pdf]</a>
</p>
<div class="box"  >
<p>
We study the possibility of constructing encryption schemes secure under messages that are chosen depending on the key
<span class=blu2>k</span> of the encryption scheme itself. We give the following separation results that hold both in the private and in the public key settings:
<ul>
<li>Let <span class=blu2>H</span> be the family of <span class=blu2>poly(n)</span>-wise independent hash-functions. 
There exists no fully-black-box reduction from an encryption scheme secure against key-dependent messages to one-way permutations 
(and also to families of trapdoor permutations) if the adversary can obtain encryptions of <span class=blu2>h(k)</span> for <span class=blu2>h ∈ H</span>.</li>

<li>There exists no reduction from an encryption scheme secure against key-dependent messages to, essentially, <em>any</em>
cryptographic assumption, if the adversary can obtain an encryption of <span class=blu2>g(k)</span> for an <em>arbitrary</em>
g, as long as the reduction's proof of security treats both the adversary and the function <span class=blu2>g</span> as black boxes.</li>
</ul>

</div>
</li>


<li>
<p>Iftach Haitner<br>
<b>New Implications and Improved Efficiency of Constructions Based on One-way Functions</b><br>
PhD. Thesis, 2008<br>
<a href="papers/PhDThesis/FullThesis.pdf">[pdf]</a></p>
</li>

<li>
<p>Iftach Haitner<br>
<b>Semi-Honest to Malicious Oblivious Transfer -- The Black-Box Way </b><br>
<span class=abslide>[abstract]</span>  <a href="papers/SemiHonestToMalicious/SemiToMal_f.ppt">[slides]</a><br>
Theory of Cryptography Conference (TCC), 2008 <a href="papers/SemiHonestToMalicious/SemiHonestToMalicious-TCC.pdf">[pdf]</a> <br>
Full version is part of   <a href="#BBMPC"> Black-Box Constructions of Protocols for Secure Computation</a>
</p>

<div class="box"  >
<p>
Until recently, all known constructions of oblivious transfer protocols based
on general hardness assumptions had the following form. First, the hardness assumption is used in a black-box manner (i.e., the
construction uses only the input/output behavior of the primitive guaranteed by the assumption) to construct a <em>semi-honest</em>
oblivious transfer, a protocol whose security is guaranteed to hold only against adversaries that follow the prescribed protocol. Then, the
latter protocol is ``compiled" into a (malicious) oblivious transfer using non-black techniques (a Karp reduction is carried in order to
prove an NP statement in zero-knowledge). In their recent breakthrough result, <span class=blu1>Ishai, Kushilevitz, Lindel and Petrank [STOC '06] </span> deviated from
the above paradigm, presenting a black-box reduction from oblivious transfer to enhanced trapdoor permutations and to homomorphic
encryption. Here we generalize their result, presenting a black-box reduction from oblivious transfer to semi-honest oblivious transfer.
Consequently, oblivious transfer can be black-box reduced to each of the hardness assumptions known to imply a semi-honest oblivious
transfer in a black-box manner. This list currently includes beside the hardness assumptions used by Ishai et al. also the existence of
families of dense trapdoor permutations and of non trivial single-server private information retrieval. 
</p>
</div>
</li>


<li>
<p>
Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a> and&nbsp; <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<b>A Linear Lower Bound on the Communication Complexity of Single-Server Private Information Retrieval</b><br>
<span class=abslide>[abstract]</span>  <a href="papers/PIRLowerBound/PIRLowerBound.ppt">[slides]</a> <br>
Theory of Cryptography Conference (TCC), 2008 <a href="papers/PIRLowerBound/PIRLowerBound.pdf">[pdf]</a><br>
Full version is part of  <a href="#HHRSJoint">Finding Collisions in Interactive Protocols — Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>
</p>
<div class="box"  >
<p>
We  study the communication complexity of single-server Private Information Retrieval (PIR) protocols that are based on fundamental cryptographic
primitives in a black-box manner. In this setting, we establish a tight lower bound on the number of bits communicated by the server in any
polynomially-preserving construction that relies on trapdoor permutations. More specifically, our main result states that in such
constructions <span class=blu2>Ω(n)</span> bits must be communicated by the server, where <span class=blu2>n</span>
is the size of the server's database, and this improves the <span class=blu2>Ω(n / log n)</span> lower bound due to
<span class=blu1> Haitner, Hoch, Reingold and Segev [FOCS '07]</span>. Therefore, in the setting under consideration, the naive solution in which the user downloads the
entire database turns out to be optimal up to constant multiplicative factors. We note that the lower bound we establish holds for the most
generic form of trapdoor permutations, including in particular enhanced trapdoor permutations.<br>
Technically speaking, this paper consists of two main contributions from which our lower bound is obtained. First, we derive a tight lower
bound on the number of bits communicated by the sender during the commit stage of any black-box construction of a statistically-hiding
bit-commitment scheme from a family of trapdoor permutations. This lower bound asymptotically matches the upper bound provided by the
scheme of <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO '92]</span>. Second, we improve the efficiency of the reduction of statistically-hiding
commitment schemes to low-communication single-server PIR, due to <span class=blu1>Beimel, Ishai, Kushilevitz and Malkin [STOC '99]</span>. In particular, we
present a reduction that essentially preserves the communication complexity of the underlying single-server PIR protocol. 
</p>
</div>
</li>


<li>
<p>Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>
and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<b>Finding Collisions in Interactive Protocols -- A Tight Lower Bound on the Round Complexity of Statistically-Hiding Commitments</b><br>
<span class=abslide>[abstract]</span> <a href="papers/FindingCollisions/FindingCollisions.pps">[slides]</a><br>
IEEE Symposium on Foundations of Computer Science (FOCS), 2007 <a href="papers/FindingCollisions/FindingCollisions-FOCS.pdf">[pdf]</a><br>
Full version is part of  <a href="#HHRSJoint">Finding Collisions in Interactive Protocols — Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>
</p>

<div class="box"  >
<p>
We study the round complexity of various cryptographic protocols. Our main result is a tight lower bound on
the round complexity of any fully-black-box construction of a statistically-hiding commitment scheme from one-
way permutations, and even from trapdoor permutations. This lower bound matches the round complexity of the
statistically-hiding commitment scheme due to <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO ’92]</span>. 
As a corollary, we derive similar tight lower bounds for several other cryptographic protocols, such as single-server private infor-
mation retrieval, interactive hashing, and oblivious transfer that guarantees statistical security for one of the parties.<br>

Our techniques extend the collision-finding oracle due to <span class=blu1>Simon [EUROCRYPT ’98]</span> to the setting of interactive protocols 
(our extension also implies an alternative proof for the main property of the original oracle). In addition, we substantially extend the reconstruction paradigm of 
<span class=blu1> Gennaro and Trevisan (FOCS ’00]</span>. In both cases, our extensions are quite delicate and may be found useful in proving
additional black-box separation results.
</p>
</div>

</li>

<li>
<p>Iftach Haitner and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>Statistically Hiding Commitment from Any One-Way Function </b><br>
<span class=abslide>[abstract]</span> <a href="papers/SCfromOWF/SCfromOWF.pps">[slides]</a><br>
Annual ACM Symposium on Theory of Computing (STOC), 2007 <a href="papers/SCfromOWF/SCfromOWF-STOC.pdf">[pdf]</a>
Full version is part of <a href="#HONRV">Statistically Hiding Commitments and Statistical Zero-Knowledge Arguments from Any One-Way Function</a>
</p>
<div class="box" >
<p>
We give a construction of statistically-hiding commitment schemes (ones where the hiding property holds information theoretically), based on
the minimal cryptographic assumption that one-way functions exist. Our construction employs two-phase commitment schemes, recently constructed
by <span class=blu1>Nguyen, Ong and Vadhan [FOCS `06]</span>, and universal one-way hash functions introduced and constructed by <span class=blu1>Naor and Yung [STOC `89]</span> and
<span class=blu1>Rompel [STOC `90]</span>. 
</div>
</li>

<li>
<p>Iftach Haitner and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>A New Interactive Hashing Theorem </b><br>
<span class=abslide>[abstract]</span> <a href="papers/IneractiveHashing/IHSeminar_F.ppt">[slides]</a><br>

Journal of Cryptology 2014 <a  href="http://link.springer.com/article/10.1007/s00145-012-9139-0">[link]</a><br>
IEEE Conference on Computational Complexity(CCC), 2007 <a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[pdf]</a><br>
Draft of full version  <a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
Interactive hashing, introduced by <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO '92]</span>,
plays an important role in many cryptographic protocols. In particular, interactive hashing is a major component in all known constructions
(which are based on general one-way permutations and one-way functions) of statistically hiding commitment schemes and of statistical
zero-knowledge arguments. Interactive hashing with respect to a one-way permutation <span class=blu2>f</span>, is a
two-party protocol that enables a sender that knows <span class=blu2>y=f(x)</span> to transfer a random hash
<span class=blu2>z=h(y)</span> to a receiver. The receiver is guaranteed that the sender is committed to <span class=blu2>y</span> (in the sense that it cannot
come up with <span class=blu2>x</span> and <span class=blu2>x'</span> such that <span class=blu2>f(x) ≠ f(x')</span>, but <span class=blu2>h(f(x))=h(f(x'))=z</span>). The sender
is guaranteed that the receiver does not learn any additional information on <span class=blu2>y</span>. In particular, when <span class=blu2>h</span>  is a two-to-one hash
function, the receiver does not learn which of the two preimages <span class=blu2>{y,y'}=h<sup>-1</sup>(z)</span>
 is the one the sender can invert with respect to <span class=blu2>f</span>.<br>
 
This paper reexamines the notion of interactive hashing. We give an alternative proof for the Naor et al. protocol, which seems
significantly simpler and more intuitive than the original one. Moreover, the new proof achieves much better parameters (in terms of
how security preserving the reduction is). Finally, by applying our new proof to a close variant of the Naor et al. protocol, we achieve a more
versatile interactive hashing theorem for a more general setting than that of the Naor et al. protocol.
</p> 
</div>
</li>


<li>
<p><a name="RandIt">
Iftach Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>, and </a>Omer Reingold<br>
<b>On the Power of the Randomized Iterate</b> <br>
<span class=abslide>[abstract]</span> <a href="papers/RandomizedIteate/Randomized_Iterate.pps">[slides]</a><br>
SIAM Journal of Computing 2011   <a  href="http://epubs.siam.org/doi/abs/10.1137/080721820">[link]</a><br>
Advanced in Cryptology - CRYPTO, 2006 <a href="papers/RandomizedIteate/Randomized_Iterate_CryptoCR.pdf">[pdf]</a><br>
Draft of full version  <a href="papers/RandomizedIteate/RandomIterate.pdf">[pdf]</a>
</p>

<div class="box">
<p>
We consider two of the most fundamental theorems in Cryptography. The first, due to <span class=blu1> Håstad, Impagliazzo, Levin and Luby [STOC '89, STOC '90,
SIAM J. on Computing '99]</span>, is that pseudorandom generators can be constructed from any one-way function. The second, due to <span class=blu1> Yao [FOCS
'82]</span>, states that the existence of weak one-way functions implies the
existence of full fledged one-way functions. These powerful plausibility results shape our understanding of hardness and randomness
in Cryptography, but unfortunately their proofs are not as tight (i.e., security preserving) as one may desire.<br>
This work revisits a technique that we call the <i>randomized
iterate</i>, introduced by <span class=blu1>Goldreich, Krawczyk and Luby [SIAM J.
on Computing '93]</span>. This technique was used by Goldreich et al. to give a construction of pseudorandom generators from regular one-way
functions. We simplify and strengthen this technique in order to obtain a similar construction where the seed length of the resulting
generators is as short as <span class=blu2>Θ(n log n)</span> rather than <span class=blu2>Θ(n<sup>3</sup>)</span>
achieved by Goldreich et al. Our technique has the potential of implying seed-length <span class=blu2>Θ(n)</span>,
and the only bottleneck for such a result is the parameters of current generators against space bounded computations. We give a construction
with similar parameters for security amplification of regular one-way functions. This improves upon the construction of Goldreich,
<span class=blu1>Impagliazzo, Levin, Venkatesan and Zuckerman [FOCS '90]</span> in that the
construction does not need to ``know" the regularity parameter of the functions (in terms of security, the two reductions are incomparable).
In addition, we use the randomized iterate to show a construction of a pseudorandom generator based on an exponentially hard one-way function
that has seed length of only <span class=blu2>Θ(n<sup>2</sup>)</span>. This improves a recent result of <span class=blu1>Holenstein [TCC '06]</span> that shows a
construction with seed length </p>Θ(n<sup>5</sup>)</span> based on such one-way functions. Finally, we show that the randomized
iterate may even be useful in the general context of Håstad et al. In particular, we use the randomized iterate to replace the basic building
block of the Håstad et al. construction. Interestingly, this modification improves efficiency by an <span class=blu2>n<sup>3</sup></span>
factor and reduces the seed length to <span class=blu2>Θ(n<sup>7</sup>)</span> (which also implies improvement in the security of the construction). 
</p>
</div>
</li>

<li>
<p>Iftach Haitner,  <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>
and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>On EfficientPseudorandom Generators from Exponentially Hard One-Way Functions</b><br>
<span class=abslide>[abstract]</span> <a href="papers/RandomizedIteate/PrgFromHard.pps">[slides]</a><br>
International Colloquium on Automata, Languages and Programming - ICALP, 2006  <a href="papers/RandomizedIteate/PrgFromHard-ICALP.pdf">[pdf]</a><br>
Full version is part of <a href="#RandIt">On the Power of the Randomized Iterate</a>
</p>
<div class="box"  >
<p>
We show a construction of a pseudorandom generator from any exponentially
hard one-way function with a blowup of only <span class=blu2>Θ(n<sup>2</sup>)</span>.
This Improves the recent <span class=blu2> Θ(n<sup>5</sup>)</span> construction of <span class=blu1>Holenstein [TCC '06]</span>. 
Our technique uses the tools recently presented in <span class=blu1>Haitner et al. [Crypto '06]</span> for the setting of regular one-way
functions, and further develops them. 
</p>
</div>
</li>


<li>
<p>Iftach Haitner, Omer Horvitz, <a href="http://www.cs.umd.edu/%7Ejkatz/">Jonathan Katz</a>, Chiu-Yuen Koo, Ruggero Morselli and <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
<b>Reducing Complexity Assumptions for Statistically-Hiding Commitment </b><br>
<span class=abslide>[abstract]</span> <a href="papers/SCfromRegularOWF/SCfromRegularOWF.pps">[slides]</a><br>
Journal of Cryptology 2009 <a  href="http://link.springer.com/content/pdf/10.1007/s00145-007-9012-8">[link]</a><br>
Advances in Cryptology - Eurocrypt, 2005  <a href="papers/SCfromRegularOWF/SCfromRegularOWF-eurocrypt.pdf">[pdf]</a><br>
Draft of full version  <a href="papers/SCfromRegularOWF/SCfromRegularOWF-JOC.pdf">[pdf]</a>
</p>
<div class="box"  >
<p>
We revisit the following question: <em>what are the minimal
assumptions needed to construct statistically-hiding commitment schemes</em>?
<span class=blu1> Naor et al. [J. Cryptology 98]</span> show how to construct such schemes based on any one-way
permutation. We improve upon this by showing a construction based on any approximable preimage-size one-way function.
These are one-way functions for which it is possible to efficiently approximate the number of pre-images of a given output. A special case
is the class of <em>regular</em> one-way functions where all points in the image of the function have the same (known) number of
pre-images.<br>

We also prove two additional results related to statistically-hiding commitment. First, we prove a (folklore) <em parallel composition theorem></em> 
showing, roughly speaking, that the statistical hiding property of any such commitment scheme is amplified exponentially when multiple independent parallel
executions of the scheme are carried out. Second, we show a <em>compiler</em> which transforms any commitment scheme which is statistically hiding
against an honest-but-curious receiver into one which is statistically hiding even against a malicious receiver.
</p>
</div>
</li>

<li>
<p>Iftach Haitner<b><br>
Implementing Oblivious Transfer Using a Collection of Dense Trapdoor Permutations</b><br>
<span class=abslide>[abstract]</span> <a href="papers/OTDenseTDP/OTDenseTDP.pps">[slides]</a><br>
Theory of Cryptography Conference (TCC), 2004  <a href="papers/OTDenseTDP/OT_Dense_TCC.pdf">[pdf]</a> <br>
Draft of full version <a href="papers/OTDenseTDP/OTDenseTDP.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
Until recently, the existence of collection of trapdoor permutations (TDP) was believed (and claimed) to imply almost all of the
major cryptographic primitives, including public-key encryption (PKE), oblivious transfer (OT), and non-interactive zero-knowledge (NIZK). It
was recently realized, however, that the commonly accepted general definition of TDP needs to be strengthened slightly in order to make the
security proofs of TDP-based OT go through. We present an implementation of oblivious transfer based on collection of dense trapdoor permutations. 
The latter is a collection of trapdoor permutations, with the property that the permutation domains are polynomially dense in the
set of all strings of a particular length. Previous TDP-based implemen tations of oblivious transfer assumed an enhancement of the hardness
assumption (of the collection). <br>

Here we present an alternative construction that only requires the TDP to have <em>dense</em> domains. Specically we present
an implementation of OT based on any dense TDP.
</p>
</div>

</li>
</ul>
</div> <!------------end wrapper----------------------->


<p align="justify"><!-- Start of StatCounter Code -->
</p>
<p align="justify"> </p>
</div> <!--wrapall-->


</body></html>