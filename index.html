  <!DOCTYPE html>
<html><head><title>Iftach Haitner's Home Page</title>
<script type="text/javascript" src="jquery.js"></script>
<style>
BODY { font-family :  verdana, arial, helvetica, sans-serif; BACKGROUND-COLOR: #eee ; color : #333  ; }
.shadow1 {box-shadow: 5px 5px 20px #888888; line-height : 150% ;}
.shadow2 {box-shadow: 5px 5px 20px #888888; border-radius : 8px }
  #iftach_pic {  background-image: url(iftach_pic_back.jpg);width : 192px ; height:233px  }
   .backup {   background-position :top   }
  .backdown {    background-position : bottom   }
 #wrapall {  max-width : 1100px ; margin:auto}
  #wrapper {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; margin-left : 30px ; padding-bottom : 30px }
strong, b {    color : #636363 }
   .abslide { color : #3956CC  ; cursor : pointer ;  }
 .abslide:hover {  text-decoration: underline;   }
 #wrapper div.box {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; margin-bottom : 20px}
  #wrapper div.box p {    margin : 0px ; }
    #topwrap {  font-size : 80%;  background-color :  #dddddd ;  padding-top : 20px;  padding-right : 40px ; ; margin-left : 30px ;  padding-bottom : 30px }
   #topwrap div.top {   display : none ; padding : 10px ; margin : 0px ; margin-top : 20px ;background-color  : white ; border : 1px dotted black ; width : 80% ;  box-shadow: 8px 8px 20px #888888; line-height : 150% ;}
      #topwrap div.top a:hover {      text-decoration : underline     }
    #pub1 li {      line-height : 150% ; }
     a {      color : #3956CC  ; text-decoration : none   }

  .boxtop { color : #3956CC  ; cursor : pointer ; font-size :150%  }
 .boxtop:hover {  text-decoration: underline;   }
    #topwrap  ul {     list-style: none   }
      h1 {      font-size : 150% ; color :  #636363   }
    h2 {     font-size : 120%  }
 .update {  position : relative;top : 2px ; left : 10px ;border : 1px solid #91BF46 ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; padding-right : 0px; padding-left: 0px }
   .update1 {  position : relative;top : 2px ; left : 10px ; border-radius : 10px ;  box-shadow: 2px 2px 5px #888888; }

 .blu1 {color: #000080;}
.blu2 {color: #003FFF; }



</style>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="Iftach Haitner, Iftach, Haitner, ×™×¤×ª×— ×”×™×˜× ×¨, ×”×™×™×˜× ×¨, ×™×¤×ª×—, Home Page, Cryptography">
<meta content="Iftach Haitner's Home Page" name="description">
<script language="JavaScript" type="text/JavaScript">


 $(document).ready(function(){
     $('.abslide').click(function(){$(this).closest('li').find(".box").slideToggle("slow","swing")});

     $('#iftach_pic').click(function(){$(this).toggleClass("backdown")});

     $(".boxtop").click(topslide);
   function topslide(){
   kukuclass="." +this.id  ;$(".top").hide("slow") ;
   $("#info").closest('div').find(kukuclass ).show("slow","swing")    ;    }
           });

</script>


<!-- Google Analytics -->
<script>
/**
 * Creates a temporary global ga object and loads analy  tics.js.
 * Paramenters o, a, and m are all used internally.  They could have been declared using 'var',
 * instead they are declared as parameters to save 4 bytes ('var ').
 *
 * @param {Window}      i The global context object.
 * @param {Document}    s The DOM document object.
 * @param {string}      o Must be 'script'.
 * @param {string}      g URL of the analytics.js script. Inherits protocol from page.
 * @param {string}      r Global name of analytics object.  Defaults to 'ga'.
 * @param {DOMElement?} a Async script tag.
 * @param {DOMElement?} m First script tag in document.
 */
(function(i, s, o, g, r, a, m){
  i['GoogleAnalyticsObject'] = r; // Acts as a pointer to support renaming.

  // Creates an initial ga() function.  The queued commands will be executed once analytics.js loads.
  i[r] = i[r] || function() {
    (i[r].q = i[r].q || []).push(arguments)
  },

  // Sets the time (as an integer) this tag was executed.  Used for timing hits.
  i[r].l = 1 * new Date();

  // Insert the script tag asynchronously.  Inserts above current tag to prevent blocking in
  // addition to using the async attribute.
  a = s.createElement(o),
  m = s.getElementsByTagName(o)[0];
  a.async = 1;
  a.src = g;
  m.parentNode.insertBefore(a, m)
})(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

ga('create', 'UA-4194129-2', 'auto'); // Creates the tracker with default parameters.
ga('send', 'pageview');            // Sends a pageview hit.
</script>

<!-- End Google Analytics -->


<!--LOAD JQUERY GOOGLE ANALYTICS OUTBOUND LINKS TRACKER - TEST-->
<script>
/* Attach tracking to all download & external links */
var _gaq = _gaq || [];

function _gaLt(event){
    var el = event.srcElement || event.target;

    /* Loop through parent elements if clicked element is not a link (ie: <a><img /></a> */
    while(el && (typeof el.tagName == 'undefined' || el.tagName.toLowerCase() != 'a' || !el.href))
        el = el.parentNode;

    if(el && el.href){
        dl = document.location;
        l = dl.pathname + dl.search;
        h = el.href;
        c = !1;
        if(h.indexOf(location.host) == -1){
            c = "Outgoing Links";
            a = h;
        }
        else if(h.match(/\/assets\//) && !h.match(/\.(jpe?g|pdf|ps|pptx|ppsx)$/i)){
            c = "Downloads";
            a = h.match(/\/assets\/(.*)/)[1];
        }
        if(c){
            _gaq.push(["_trackEvent",c,a,l]);
            /* Push secondary tracker if set */
            _gaq2 && _gaq.push(["b._trackEvent",c,a,l]);
            /* if target not set delay opening of window by 0.5s to allow tracking */
            if(!el.target || el.target.match(/^_(self|parent|top)$/i)){
                setTimeout(function(){
                    document.location.href = el.href;
                }.bind(el),500);
                /* Prevent standard click */
                event.preventDefault ? event.preventDefault() : event.returnValue = !1;
            }
        }

    }
}

var d = document;
d.addEventListener ? d.addEventListener("click",_gaLt,!1) : d.attachEvent && d.attachEvent("onclick",_gaLt);
</script>
</head>
<body>
<div id=wrapall>
  <div id=topwrap style="padding-left : 40px">
<h1>Iftach Haitner - <span style="font-size : 125%"> ×™×¤×ª×— ×”×™×™×˜× ×¨</span> </h1>

<div   alt="" class="backup shadow2" id="iftach_pic"></div>
<p style="font-size : 110%"> I am a faculty member at the <a href="https://en.cs.tau.ac.il/computer">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.
I am the director of the  <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security</a> and a member of the <a href="http://www.cs.tau.ac.il/~theory/">Theory of Computation Group</a>.<br><br>
My main research interests are Cryptography and Computational
Complexity.<br></p>

<span class=boxtop id=info>[Info]</span>
<span class=boxtop id=bio>[Short Bio]</span>
<span class=boxtop id=pro>[Professional Activity]</span>
<span class=boxtop id=teach>[Teaching]</span>  
<span class=boxtop id=edu>[School Activity]</span></br>
<span class=boxtop id=Stuff>[Group Members]</span>
<span class=boxtop id=postdocs>[Call for Postdocs & Interns]</span>


<div class="Stuff top">
<h2>Group Members</h2>
<b>Students</b><br>
<ul>

<li> Eliad Tsfadia (PhD)</li>
<li> Noam Mazor (PhD)</li>
<li> Jad Silbak (PhD) </li>
<li> Dror Chawin (MSc)</li>
<li> Yonatan Karidi-Heller (MSc)</li>



</ul>

<!---
<b>Postdocs</b><br>
<ul>
<li>   <a href="http://wicom.upf.edu/node/98">Nikolaos Makriyannis</a></li>
</ul>
<br>

--!>

<b>Past members</b><br>
<ul>
<li>   <a href="http://people.csail.mit.edu/itayberm/">Itay Berman</a> (MSc)</li>
<li>   <a href="http://people.csail.mit.edu/itayberm/">Eran Omri</a> (Postdoc)</li>
<li>   <a href="http://chrisbrzuska.de/">Christopher Brzuska</a> (Postdoc)</li>
<li>   <a href="http://cs.nyu.edu/~tentes/Homepage.html">Aris Tentes</a> (longterm student visitor)</li>
<li> Nissan Levi (MSc student)</li>
<li>   <a href="http://people.csail.mit.edu/rancohen/">Ran Cohen (Postdoc)</a></li>
<li> Matan Orland (MSc student)</li>
<li>   <a href="http://wicom.upf.edu/node/98">Nikolaos Makriyannis (Postdoc)</a></li>

</ul>
<br>
 </div>
 

 

<div class="info top">
<h2>Contact Information</h2>
Tel Aviv university, Check Point Building, Office 444 (forth floor)<br>
Phone:+972-3-6407996<br>
Fax: +972-3-6409373<br>
Email: iftachh [at] tau.ac.il<br>
Mail: Iftach Haitner, Tel Aviv university, P.O.B. 39040, Ramat Aviv, Tel Aviv 69978, Israel <br>
 </div>

<div class="bio top">
<h2>Short Biography </h2>
I am a faculty  member of the <a href="http://www.cs.tau.ac.il">School of Computer Science</a>
at <a href="http://www.tau.ac.il">Tel Aviv University</a>.<br>
I am the director of the  <a href="http://cpiis.cs.tau.ac.il/">Check Point Institute for
Information Security</a> and a member of the <a href="http://www.cs.tau.ac.il/~theory/">Theory of Computation Group</a>.<br>
Until July 2010, I was a postdoctoral researcher at <a href="http://research.microsoft.com/en-us/labs/newengland/">Microsoft
Research New England</a>. Prior to the time at Microsoft
Research, I did a six months postdoc at <a href="http://www.cs.haifa.ac.il/"><font>Department of
Computer Science, University of Haifa</font></a>, hosted by
<a href="http://cs.haifa.ac.il/%7Eronen/"> Ronen
shaltiel</a>.
I received my PhD in 2008 from the <a href="http://www.wisdom.weizmann.ac.il/">Faculty of
Mathematics and Computer Science, Weizmann Institute of Science</a>,  under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/">Omer
Reingold</a>. I got my Master's degree also
from the Weizmann Institute, under the supervision of <a href="http://www.wisdom.weizmann.ac.il/%7Eoded/">Oded
Goldreich</a>, and did my undergraduate studies (Mathematics and
Computer Science) at <a href="http://www.tau.ac.il/">Tel-Aviv
university</a>.<br><br>


<b>Awards and Fellowships</b><br>
<ul>

<li> [2018] The Kadar Family Award for Outstanding Research. </li>

<li> [2014] The annual fruits of the Raymond and Beverly Sackler Career Development Chair, awarded by the Faculty
of Exact Sciences, Tel Aviv University, in recognition of academic excellence. </li>
<li>[2011] One of the three winning papers of the 2011 SIAM Outstanding  Paper Prizes.<br>
The prizes are given for outstanding papers published in SIAM journals during the three years prior to the year of the award. </li>
<li> [2008] The John F. Kennedy Prize (awarded by the  Weizmann Institute) </li>
<li> [2008] Intel (Israel) award for outstanding Ph.D. students</li>
<li> [2008] Rothschild Fellowship for Post-Doctoral  Research (declined)</li>
<li> [2007] Otto Schwartz prize for excellent studies, PhD</li>
<li> [2007] Dean's List of Honour at the Weizmann Institute of Science</li>
<li> [2006] Best paper CRYPTO 2006</li>
<li> [2006] Best paper award ICALP 2006 track C</li>
</ul>
<br>

<b>Teaching Awards</b><br>
<ul>
<li> [2018] The Tel Aviv university  Rector's Award for Excellence in Teaching. <li>
<li> [2017] The Tel Aviv university  Rector's Award for Excellence in Teaching. <li>
</ul>
<br>

<b>Grants</b><br>
<ul>
<li>[2020-2021] Blavatnik ICRC (Interdisciplinary Cyber Research) -- Group grant. </li>
<li>[2019-2023] Israel  Science Foundation (ISF) -- Individual research grant. </li>
<li>[2015-2020] European Research Council (ERC) Starting Grant  -- Individual research grant. </li>
<li>[2015-2018] Blavatnik ICRC (Interdisciplinary Cyber Research) -- Group grant. </li>
<li>[2011-2015] Israel  Science Foundation (ISF) -- Individual research grant. </li>
<li>[2011-2015] Israel Science Foundation (ISF) -- Equipment for new faculty. </li>
<li>[2011-2015] Israel Science Foundation(ISF) -- Israeli Center of Research Excellence in Algorithms. </li>
<li>[2011-2015] US-Israel Binational Science Foundation
(BSF), with Salil Vadhan.</li>
</ul>



</div>



 <div class="pro top">
<h2>Professional Activity</h2>

<b>Editor</b><br>
<ul>
<li> <a href="https://www.siam.org/Publications/Journals/SIAM-Journal-on-Computing-SICOMP/editorial-board">SIAM Journal on Computing (SICOMP)</a></li>
</ul>

<b>Program Committees</b><br>
<ul>



<li> <a href=https://www.itsoc.org/conferences/submit/information-theoretic-cryptography-itc-2020>Conference on Information-Theoretic Cryptography (ITC) 2020</a></li>


<li> <a href="https://eurocrypt.iacr.org/2019/">Eurocrypt 2019</a></li>

<li> <a href="https://tcc.iacr.org/2018/">Theory  of Cryptography Conference (TCC) 2018</a></li>

<li> <a href="http://www.easyconferences.eu/icalp2016">ICALP 2016  (Track A)</a></li>

 <li> <a href="http://www.iacr.org/workshops/tcc2014/">Theory of  Cryptography Conference (TCC) 2014</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2013/">CRYPTO 2013</a></li>
<li> <a href="http://computationalcomplexity.org/Archive/2013/cfp.html">Conference on Computational Complexity (CCC) 2013</a></li>
<li> <a href="http://www.iacr.org/workshops/tcc2012/">Theory  of Cryptography Conference (TCC) 2012</a></li>
<li> <a href="http://cist.korea.ac.kr/%7Easiacrypt2011/">Asiacrypt 2011</a> </li>
<li> <a href="http://ct-rsa2011.di.uoa.gr/CT-RSA_2011/Welcome___CT-RSA_2011.html">CT-RSA  2011</a></li>
<li> <a href="http://www.crypto.ethz.ch/tcc2010/">Theory  of Cryptography Conference (TCC) 2010</a></li>
<li> <a href="http://www.iacr.org/conferences/crypto2009/">CRYPTO  2009</a></li>
</ul>
<b>Seminars   and Workshops </b>
<UL>

 <li>Co-organizer  of the <a href="http://www.cs.tau.ac.il/cseminar/">Greater Tel Aviv Area Cryptography Seminar (GTACS)</a></li></br>
 
 
<li>Co-organizer of the <a href="https://cryptolowerbounds.wordpress.com/">Lower Bounds in Cryptography 2019</a></li>

<li>Co-organizer of the <a href="https://www.gilsegev.net/crypto-in-the-galilee-2018">Crypto in the Galilee 2018</a></li>

<li>Co-organizer of the <a href="https://desertcrypt2015.workshop.org.il/">Second Desert Workshop in Cryptography 2016</a></li>

<li>Co-organizer of the <a href="http://intractability2013.workshop.org.il/">Modeling  Intractability workshop 2013</a></li>



</UL>
<b>Teaching</b> (outside of TelAviv university)
<ul>
<li><a href="http://iss.bu.edu/bobak/csnexus/secrecytitles.html">Nexus of Information and Computation Theories (Secrecy and Privacy Theme), 2016</a></li>
<li><a href="http://crypto.biu.ac.il/winterschool2014/">4th  Bar-Ilan Winter School on Cryptography, 2014</a></li>
<li> <a href="http://blackboxsummerschool.wordpress.com/">School on   Black-Box Impossibility Results, 2014  </a></li>
</ul>

<b>Other</b>
<ul>
<li>General co-chair of <a href="http://www.cs.tau.ac.il/conferences/tcc2016/">Theory of  Cryptography Conference (TCC) 2016-A</a></li>
</ul>

</div>

 <div class="teach top">
<h2> Teaching  </h2>
<ul>

<li><a href="https://moodle.tau.ac.il/2019/course/view.php?id=368448601"> Applications of Information Theory&nbsp; (Fall 19)</a></li>

<li><a href="https://moodle.tau.ac.il/2019/course/view.php?id=368415201"> Zero Knowledge Proofs (student seminar)&nbsp; (Fall 19)</a></li>

<li><a href="http://moodle.tau.ac.il/2019/course/view.php?id=368220001">Computational Models (Fall 19)</a></li>

<li><a  href="http://moodle.tau.ac.il/2018/course/view.php?id=368416201">Foundation  of Cryptography, the Basics (Spring 19)</a></li>



 <li><a href="http://moodle.tau.ac.il/2018/course/view.php?id=368419701"> Seminar on pseudorandomness (student seminar)&nbsp; (Fall 18)</a></li>


	
 <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/DP/Spring18.html"> Seminar on Differential Privacy (student seminar)&nbsp; (Spring 18)</a></li>



 <li><a  href="http://moodle.tau.ac.il/2016/course/view.php?id=368413101"> Foundation  of Cryptography, Advanced Topics (Spring 17)</a></li>

 
  <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/MPC/Spring17.html"> Multi-Party Computation (student seminar)&nbsp; (Spring 17)</a></li>

  


    

  <li><a href="http://www.cs.tau.ac.il/%7Eiftachh/Courses/Seminars/AvgHardness/Spring15.html"> Average-Case Hardness (student seminar)&nbsp; (Spring 15)</a></li>
 
 <br><br>
  
   <li><a href="https://groups.google.com/forum/#!forum/foc-at-tau"> Advanced Cryptography seminar (by invitation only).&nbsp; Thursdays 13-15, Room 480</a></li>

  </ul></div>
 
 

<div class="edu top">
<h2>School Activity</h2>
<ul>
<li><a href="http://www.cs.tau.ac.il/MSCX_program/mscx.htm">Excellence Program for Master Studies</a></li>
 </ul>
</div>

<div class="postdocs top">
<h2> Call for Postdocs and Interns</h2>
See the <a href="http://cpiis.cs.tau.ac.il/postdoc-fellowships-internships/">TAU crypto group call</a>
</div>



</div> <!--topwrap-->
<!-----------------publications---------------------------------------->


 <div id=wrapper >
 <h1 style="margin-left : 30px ; margin-top : 0px">Publications   <span style="font-size :12px ; font-weight : 400">(in Reverse Chronological Order)</span></h1>

<ul id=pub1>



<li>
Dror Chawin and Iftach Haitner and Noam Mazor. <br>
<strong>Lower Bounds on the Time/Memory Tradeoff of Function Inversion</strong>  <img src="new.png" class=update1><br>
<span class=abslide>[abstract]</span> <br>
TCC 2020<br>
Draft of full version  <a href="papers/TimeMemTO/TimeMemTO.pdf">[pdf]</a><br><br>

<div class="box">
<p><span class=blu1></span><span class=blu2></span>
We study time/memory tradeoffs of function inversion: an algorithm, i.e.,  an  inverter,  equipped with  an <span class=blu2>s</span>-bit advice for a randomly chosen function <span class=blu2>f:[n]&rarr;[n]</span> and using <span class=blu2>q</span>  oracle queries to <span class=blu2>f</span>,
 tries to invert a randomly chosen output <span class=blu2>y</span> of <span class=blu2>f</span>  (i.e., to find <span class=blu2>x</span> such that <span class=blu2>f(x)=y</span>).  <br><br>
  
Much progress was done regarding  adaptive function inversion---the inverter is allowed to make  adaptive  oracle queries. 
 <span class=blu1>Hellman [IEEE transactions on Information Theory '80]  </span> presented an adaptive  inverter   that inverts with high probability  a random <span class=blu2>f</span>. 
 <span class=blu1>Fiat and Naor [SICOMP '00]</span> proved that  for any <span class=blu2>s,q</span> with <span class=blu2>s<sup>2</sup>q = n<sup>2</sup></span>  (ignoring low-order  terms), an <span class=blu2>s</span>-advice, <span class=blu2>q</span>-query   
 variant of Hellman's  algorithm inverts a constant fraction of the image points of any function.   <span class=blu1>Yao  [STOC '90]</span> proved a lower bound of <span class=blu2>sq &ge;  n</span> for  this problem. 
 Closing the gap between the above lower and upper bounds is a long-standing open question.

<br><br>

Very little is known for the non-adaptive variant of the question---the inverter chooses  its queries in advance. 
The only known upper bounds, i.e., inverters, are the trivial ones (with <span class=blu2>s+q= n</span>), and the only lower bound is the above bound of  <span class=blu1>Yao</span>. 
In a recent work, <span class=blu1>Corrigan-Gibbs and Kogan  [TCC '19]</span> partially justified the difficulty of finding lower bounds on non-adaptive inverters, 
showing that  a lower bound on the time/memory tradeoff of  non-adaptive inverters implies a lower  bound on low-depth Boolean circuits. Bounds that  for a strong  enough choice of parameters, are notoriously hard to prove. 
<br><br>


We make progress on the above intriguing  question, both for the adaptive and the non-adaptive case, proving the  following lower bounds on restricted families of  inverters:<br><br>

	<ul> Linear-advice (adaptive inverter). If the advice string is a linear function of <span class=blu2>f</span> (e.g., <span class=blu2>A&times; f</span>, viewing <span class=blu2>f</span> as  a vector in <span class=blu2>[n]<sup>n</sup></span>), 
	then <span class=blu2>s+q &isin; &Omega;(n)</span>.</ul> <br>
	
	<ul>Affine non-adaptive decoders. If the  non-adaptive inverter  has an affine decoder---it  
	outputs  a linear function, determined by the advice string and the element to invert, of the query answers---then <span class=blu2>s &isin; &Omega;(n)</span> (regardless of   <span class=blu2>q</span>).</ul> <br>
	
	<ul>Affine non-adaptive decision trees. If the  non-adaptive inversion algorithm is a d-depth affine decision tree---it outputs the evaluation of a decision tree whose nodes compute  a linear function of the answers to the queries---and <span class=blu2>q < cn</span> for 
	some universal <span class=blu2>c>0</span>, then <span class=blu2>s &isin; &Omega;(n/d*log(n))</span>.</ul>  



</p>
</div>
</li>

<li>
<a href="https://www.cs.bgu.ac.il/~beimel/">Amos Beimel </a> and Iftach Haitner and <a href="http://people.cs.georgetown.edu/~kobbi/">Kobbi Nissim</a> and  <a href="https://www.uri.co.il/">Uri Stemmer</a> <br>
<strong>On the Round Complexity of the Shuffle Model</strong>  <img src="new.png" class=update1><br>
<!-- <span class=abslide>[abstract]</span> <br> --!>
TCC 2020<br> <br>

<div class="box">
<p><span class=blu1></span><span class=blu2></span>
Soon...
</p>
</div>
</li>


<li>Iftach Haitner and Yonatan Karidi-Heller. <br>
<strong>A Tight Lower Bound on Adaptively Secure Full-Information Coin Flip</strong>  <img src="new.png" class=update1><br>
<span class=abslide>[abstract]</span> <br>
FOCS 2020<br>
Draft of full version  <a href="papers/FullCoin/FullCoin.pdf">[pdf]</a><br><br>

<div class="box">
<p>
In a distributed coin-flipping protocol, <span class=blu1>Blum [ACM Transactions on Computer Systems '83]</span>, the parties try to output a common (close to) uniform bit, 
even when some adversarially chosen parties try to bias the common output.  In an adaptively secure full-information coin flip, <span class=blu1>Ben-Or and Linial [FOCS '85]</span>, the parties communicate over a broadcast channel and a computationally unbounded adversary can choose which parties to corrupt during the protocol execution. Ben-Or and Linial proved that the <span class=blu2>n</span>-party majority protocol is resilient to <span class=blu2>O(&radic;<span style="text-decoration:overline;">n</span>)</span>  corruptions (ignoring poly-logarithmic  factors), and conjectured this is a tight upper bound for any <span class=blu2>n</span>-party protocol (of any round complexity). Their conjecture was proved to be correct for limited variant of single-turn (each party sends a single message) single-bit (a message is one bit) protocols, <span class=blu1>Lichtenstein, Linial, and Saks [Combinatorica '89]</span>, symmetric protocols <span class=blu1>Goldwasser, Kalai, and Park [ICALP '15]</span>, and recently for (arbitrary message length) single-turn protocols  <span class=blu1>Kalai, Komargodski, and Raz [DISC '18]</span>. Yet, the question for many-turn (even single-bit) protocols was left completely open.<br><br>

In this work we close the above gap, proving that no <span class=blu2>n</span>-party protocol (of any round complexity) is resilient to <span class=blu2>&omega;(&radic;<span style="text-decoration:overline;">n</span>)</span>  (adaptive) corruptions. That is, up tp polylog factors, the single-bit, single-message majority protocol is the optimal  protocol against adaptive corruptions.   
</p>
</div>
</li>

<li>
Iftach Haitner,   <a href="https://omereingold.wordpress.com/">Omer Reingold</a>,
<a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a> and  <a href="https://www.di.ens.fr/~wee/">Hoeteck Wee</a><br>
 <b>IE1: Inaccessible Entropy Generators and Statistically Hiding
Commitments from One-Way Functions</b> <img src="up.png" class=update1><br>Manuscript 2020<br>
<span class=abslide>[abstract]</span> <br>
Draft of full version  <a href="papers/AccessibleEntropy/IE1.pdf">[pdf]</a><br>

A preliminary version, with a different notion of accessible entropy, appeared in <span class=blu1>Inaccessible Entropy [STOC '09]</span><br><br>
<div class="box">
<p>
We put forth a new computational notion of entropy, measuring the (in)feasibility of sampling
high-entropy strings that are consistent with a given generator. Specifically, the i'th output block
of a generator <span class=blu2>G</span> has accessible entropy at most <span class=blu2>k</span> if the following holds: when conditioning on its
prior coin tosses, no polynomial-time strategy <span class=blu2>G*</span>
can generate valid output for <span class=blu2>G</span>'s <span class=blu1>i</span>'th output block with entropy greater than <span class=blu2>k</span>. 
A generator has inaccessible entropy if the total accessible
entropy (summed over the blocks) is noticeably smaller than the real entropy of <span class=blu2>G</span>'s output.<br>
As an application of the above notion, we improve upon the result of <span class=blu1>Haitner, Nguyen, Ong,
Reingold, and Vadhan [Sicomp '09]</span>, presenting a much simpler and more ecient construction
of statistically hiding commitment schemes from arbitrary one-way functions.
</p>
</div>
</li>


<li>
<a href="http://people.csail.mit.edu/itayberm/">Itay Berman</a> and Iftach Haitner and Eliad Tsfadia. <br>
<strong>A Tight Parallel Repetition Theorem for Partially Simulatable Interactive Arguments via Smooth KL-Divergence</strong>  <img src="new.png" class=update1><br>
<span class=abslide>[abstract]</span> <br>
Crypto 2020<br>
Draft of full version  <a href="papers/TightPR/TightPR.pdf">[pdf]</a><br><br>

<div class="box">
<p>
Hardness amplification is a central problem in the study of interactive protocols. 
While "natural" parallel repetition transformation is known to reduce the soundness error of some special cases of interactive arguments: 
 three-message protocols (<span class=blu1>Bellare, Impagliazzo, and Naor[FOCS '97]</span>) and public-coin protocols (<span class=blu1>Haastad, Pass, Wilkstrom, and Pietrzak [TCC '10]</span>,<span class=blu1> Chung and Lu [TCC '10]</span> and <span class=blu1>Chung and Pass [TCC '15]</span>), 
it fails to do so in the general case (the above <span class=blu1>Bellare, Impagliazzo, and Naor</span>; also <span class=blu1>Pietrzak and Wikstroom [TCC '07]</span>).
 <br> <br>

The only known round-preserving approach that applies to all interactive arguments is <span class=blu1>Haitner's</span> random-terminating transformation  <span class=blu1>[FOCS '09, SiCOMP '13]</span>, 
who showed that the parallel repetition of the transformed protocol reduces the soundness error at a weak exponential rate: 
if the original <span class=blu2> m</span>-round protocol has soundness error  <span class=blu2> 1- &epsilon;</span>, then the <span class=blu2>n</span>-fold 
repetition of its random-terminating variant has soundness error <span class=blu2> (1- &epsilon;)<sup>&epsilon;n/m<sup>4</sup></sup></span> 
(omitting constant factors). Hastad et al. have generalized this result to partially simulatable interactive arguments, 
showing that the <span class=blu2> n</span>-fold repetition of an <span class=blu2> m</span>-round <span class=blu2> &delta;</span>-simulatable argument of 
soundness error  <span class=blu2> 1- &epsilon;</span> has soundness error <span class=blu2> (1- &epsilon;)<sup>&epsilon;&delta;<sup>2</sup>n/m<sup>2</sup></sup></span>.
When applied to random-terminating arguments, the Hastad et al. bound matches that of Haitner.
<br> <br>
 
In this work we prove that parallel repetition of random-terminating arguments reduces the soundness error at a much stronger exponential rate: 
the soundness error of the  <span class=blu2>n</span>-fold  repetition is <span class=blu2> (1- &epsilon;)<sup>n/m</sup></span>, only an <span class=blu2>m</span> 
factor from the optimal rate of <span class=blu2> (1- &epsilon;)<sup>n</sup></span> achievable in public-coin and three-message arguments. 
The result generalizes to <span class=blu2> &delta;</span>- arguments, for which we prove a bound of <span class=blu2> (1- &epsilon;)<sup>&delta;n/m</sup></span>. 
This is achieved by presenting a tight bound on a relaxed variant of the KL-divergence between the distribution induced by our reduction and its ideal variant, 
a result whose scope extends beyond parallel repetition proofs. We prove the tightness of the above bound for random-terminating arguments, 
by presenting a matching protocol.
</p>
</div>
</li>


<li>
<a href="https://people.csail.mit.edu/rancohen/">Ran Cohen</a> and Iftach Haitner and Nikolaos Makriyannis and Matan Orland and <a href="http://www.cs.huji.ac.il/~salex/">Alex Samorodnitsky</a></a><br>
<strong>On the Round Complexity of Randomized Byzantine Agreement</strong> <br>
<span class=abslide>[abstract]</span> <br>
DISC  2019<br>
Draft of full version  <a href="papers/ByzAgmntLB/BA_Full.pdf">[pdf]</a><br><br>





<div class="box">
<p>
We present new  lower bounds on the round complexity of <em>randomized</em> Byzantine agreement (BA) protocols, bounding the halting probability of such protocols after one and two rounds. In particular, we prove that:<br><br>
<ol>
<li> BA protocols resilient against <span class=blu2>n/3</span> [resp., <span class=blu2>n/4</span>] corruptions terminate (under attack) at the end of the first round with probability at most <span class=blu2>o(1)</span> [resp., <span class=blu2>1/2 + o(1)</span>].</li>

<li> BA protocols resilient against <span class=blu2>n/4</span> corruptions terminate at the end of the second round with probability at most <span class=blu2>1 - &Theta;(1)</span>.</li>

<li> For a large class of protocols (including all BA protocols used in practice) and under a plausible combinatorial conjecture, BA protocols resilient against <span class=blu2>n/3</span> [resp., <span class=blu2>n/4</span>] corruptions
terminate at the end of the second round with probability at most <span class=blu2>o(1)</span> [resp., <span class=blu2>1/2 + o(1)</span>].</li>


</ol><br>

The above bounds allow the parties to use a public-key infrastructure (PKI), or, more generally, to have a pre-interaction phase in which a trusted party honestly distributes values (i.e., shares) between the parties.
The third bound essentially matches the recent protocol of <span class=blu1>Micali (ITCSâ€™17)</span> that tolerates up to n/3 corruptions and terminates at the end of the third round with constant probability.
</p>
</div>
</li>





<li>
Iftach Haitner and Noam Mazor and <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a> and Jad Silbak. <br>
<strong>Channels of Small Log-Ratio Leakage and
Characterization of Two-Party Differentially Private Computation</strong><br>
<span class=abslide>[abstract]</span> <br>
TCC 2019<br>
Draft of full version  <a href="papers/LogRatioChannels/LogRatioChannels.pdf">[pdf]</a><br><br>

<div class="box">
<p>
Consider a ppt two-party protocol <span class=blu2> &Pi; = (A,B)</span> in which the parties get no private inputs nd obtain outputs <span class=blu2> O<sup>A</sup>,O<sup>B</sup> &in;{0,1}</span>, and let <span class=blu2> V<sup>A</sup>,V<sup>B</sup></span> denote the parties' individual views.
Protocol <span class=blu2> &Pi;</span> has <span class=blu2> &alpha;</span>-agreement if <span class=blu2> Pr[O<sup>A</sup>=O<sup>B</sup>]&geq; 1/2 + &alpha; </span>. The leakage of <span class=blu2> &Pi;</span> is the amount of information a party obtains about the event <span class=blu2> {O<sup>A</sup>=O<sup>B</sup>}</span>; that is, the leakage <span class=blu2> &epsilon;</span> is the maximum, over <span class=blu2> P&in;{A,B}</span>, of the distance between <span class=blu2>V<sup>P</sup>|<sub>O<sup>A</sup>=O<sup>B</sub></span> and <span class=blu2>V<sup>P</sup>|<sub>O<sup>A</sup>&ne;O<sup>B</sub></span>. Typically, this distance is measured in statistical distance, or, in the computational setting, in computational indistinguishability. For this choice, <span class=blu1>Wullschleger [TCC `09] </span> showed that if <span class=blu2> &alpha;&ll;&epsilon;</span> then the protocol can
be transformed into an OT protocol.<br><br>


We consider measuring the protocol leakage by the log-ratio distance (which was popularised by its use in the differential privacy framework). The log-ratio distance between <span class=blu2> X; Y </span>  over domain 
 <span class=blu2> &Omega;</span>is the minimal <span class=blu2> &epsilon;&geq;0</span>  for which, for every <span class=blu2> v\in &Omega;</span>, <span class=blu2> log (Pr[X=v]/Pr[Y =v]) &in; [-&epsilon;,&epsilon;]</span>. In the computational setting, we use computational indistinguishability from having log-ratio distance <span class=blu2> &epsilon;</span>. We show that a protocol with (noticeable) accuracy <span class=blu2> &alpha;&in;&Omega;(&epsilon;<sup>2</sup>)</span> can be transformed into an OT
protocol. We complete the picture, in this respect, showing that
a protocol with <span class=blu2> &alpha;&in;o(&epsilon;<sup>2</sup>)</span> does not necessarily imply OT. Our results hold both the information
theoretic and in the computational settings, and can be viewed as a "fine grained" approach to "weak OT amplification"".<br><br>

We then use the above result to fully characterize the complexity of differentially private two-party computation for the XOR function, answering the open question put by <span class=blu1>Goyal, Khurana, Mironov, Pandey, and Sahai [ICALP '16]</span> and <span class=blu1>Haitner, Nissim, Omri, Shaltiel, and Silbak [FOCS '18]</span>. Specifically, we show that for any (noticeable) <span class=blu2> &alpha;&in;&Omega;(&epsilon;<sup>2</sup>)</span>, a two-party protocol that
computes the XOR function with <span class=blu2> &alpha;</span>-accuracy and <span class=blu2> &epsilon;</span>-differential privacy can be transformed into an OT protocol. This improves upon <span class=blu1>Goyal et al.</span> that only handle <span class=blu2> &alpha;&in;&Omega;(&epsilon;)</span>, and upon <span class=blu1>Haitner
et al.</span> who showed that such a protocol implies (infinitely-often) key agreement (and not OT). Our characterization is tight since OT does not follow from protocols in which <span class=blu2> &alpha;&in;o(&epsilon;<sup>2</sup>)</span>, and
extends to functions (over many bits) that "contain" an "embedded copy" of the XOR function.
</p>
</div>
</li>






<li>
<a href="https://sites.google.com/site/nirbitansky/">Nir Bitansky</a>  and Iftach Haitner and <a href="http://ilan.tech.cornell.edu/">Ilan Komargodski</a> and  <a href="https://sites.google.com/site/eylonyogev/">Eylon Yogev</a>. <br>
<strong>Distributional Collision Resistance Beyond One-Way Functions</strong><br>
<span class=abslide>[abstract]</span> <br>
Eurocrypt 2019<br>
Draft of full version  <a href="papers/DCRH/DCRH.pdf">[pdf]</a><br><br>

<div class="box">
<p>
Distributional collision resistance is a relaxation of collision resistance that only requires that it is hard to sample a collision <span class=blu2>(x; y)</span> where <span class=blu2>x</span> is uniformly random and <span class=blu2>y</span> is uniformly random conditioned on colliding with <span class=blu2>x</span>. The notion lies between one-wayness and collision resistance, but its exact power is still not well-understood. On one hand, distributional collision resistant hash functions cannot be built from one-way functions in a black-box way, which may suggest that they are stronger. On the other hand, so far, they have not yielded any applications beyond one-way functions.<br><br>

Assuming distributional collision resistant hash functions, we construct constant-round statistically hiding commitment scheme. Such commitments are not known based on one-way functions and are impossible to obtain from one-way functions in a black-box way. Our construction relies on the reduction from inaccessible entropy generators to statistically hiding commitments by <span class=blu1>Haitner, Reingold, Vadhan, and Wee. (STOC '09)</span>. In the converse direction, we show that two-message statistically hiding commitments imply distributional collision resistance, thereby establishing a loose equivalence between the two notions.<br><br>

A corollary of the first result is that constant-round statistically hiding commitments are implied by average-case hardness in the class SZK (which is known to imply distributional collision resistance). This implication seems to be folklore, but to the best of our knowledge has not been proven explicitly. We provide yet another proof of this implication, which is arguably more direct than the one going through distributional collision resistance.
</p>
</div>
</li>

<li>
Iftach Haitner  and Noam Mazor and <a href="http://www.cs.tau.ac.il/~roshman/">Rotem Oshman</a> and  <a href="https://engineering.stanford.edu/people/omer-reingold">Omer Reingold</a> and  <a href="https://yehudayoff.net.technion.ac.il/">Amir Yehudayoff</a><br>
<strong>On the Communication Complexity of Key-Agreement Protocols</strong><br>
<span class=abslide>[abstract]</span> <br>

ITCS 2019<br>
Draft of full version <a href="papers/KeyAgreementLB/KeyAgreementLB.pdf">[pdf]</a><br><br>

<div class="box">
<p>
Key-agreement protocols whose security is proven in the random oracle model are an important alternative to the more common public-key based key-agreement protocols. In the random
oracle model, the parties and the eavesdropper have access to a shared random function (an "oracle"), but they are limited in the number of queries they can make to it. Unfortunately,
as shown by <span class=blu1> Impagliazzo and Rudich [STOC '89] and Barak and Mahmoody [Crypto '09]</span>, such
protocols can only guarantee limited secrecy: the key of any <span class=blu2>&ell;</span>-query protocol can be revealed
by an <span class=blu2>O(&ell;<sup>2</sup>)</span>-query adversary. This quadratic gap between the query complexity of the honest
parties and the eavesdropper matches the gap obtained by the Merkle's Puzzles protocol of
<span class=blu1>Merkle [CACM '78]</span>. <br><br>

In this work we tackle a new aspect of key-agreement protocols in the random oracle model:
their communication complexity. In Merkle's Puzzles, to obtain secrecy against an eavesdropper that makes roughly <span class=blu2>&ell;<sup>2</sup></span> queries, the honest parties need to exchange 
<span class=blu2>&Omega;(&ell;)</span> bits. We show that for protocols with certain natural properties, ones that Merkle's Puzzle has, such high
communication is unavoidable. Specifically, this is the case if the honest parties' queries are uniformly random, or alternatively if the protocol uses non-adaptive queries and has only two
rounds. Our proof for the first setting uses a novel reduction from random-oracle protocols to
the set-disjointness problem in two-party communication complexity, which is known to have
high communication cost. For the second setting we prove the lower bound directly, using
information-theoretic arguments.<br>

Understanding the communication complexity of protocols whose security is proven in the
random-oracle model is an important question in the study of practical protocols. Our results
and proof techniques are a first step in this direction.
</p>
</div>
</li>

<li>
Iftach Haitner and Nikolaos Makriyannis</a> and <a href="http://omrier.wix.com/eran-omri">Eran Omri</a> <br>
<strong>On the Complexity of Fair Coin Flipping</strong> <br>
<span class=abslide>[abstract]</span> <br>
TCC 2018<br>
Draft of full version  <a href="papers/CFtoKA/TwoPartyCoinFlipToKA.pdf">[pdf]</a><br><br>




<div class="box">
<p>
In their breakthrough result, <span class=blu1> Moran, Naor, and Segev 

[Journal of Cryptology '16]</span> show how to construct an <span class=blu2> r</span>-round-round two-party coin-flipping with bias
 <span class=blu2> &Theta;(1/r)</span>. 
 
This improves over the <span class=blu2> &Theta;(1/&radic;<span style="text-decoration:overline;">r</span>)</span>-bias protocol  of  <span class=blu1> Awerbuch, Blum, Chor, Goldwasser, and Micali [Manuscript '85]</span>, and matches the lower bound of <span class=blu1> Cleve [STOC '86]</span>. 
The protocol of  <span class=blu1> Moran et. al</span>, however, uses oblivious transfer, to be compared with the protocol of <span class=blu1> Awerbuch et. al</span> that can be based on any one-way function. 
An intriguing open question is whether oblivious transfer, or more generally "public-key primitives", is required for an <span class=blu2> o(1/r)</span>-bias coin flipping. This question was partially answered in the black-box settings by <span class=blu1> Dachman-Soled et al.
[11] [TCC '11] and Dachman-Soled et al. [12] [TCC '14]</span>, who showed that restricted types of fully black-box reductions cannot established such <span class=blu2> o(1/r)</span>-bias coin-flipping protocol from one-way functions.

<br><br>
We make progress towards answering the above question, showing that for any (constant) <span class=blu2> r &isin; N</span>, the existence of an <span class=blu2>r</span>-round <span class=blu2>o(1/r)</span>-bias coin flipping protcol implies the existence of an infinitely-often key-agreement protocol. Our reduction is non black-box, and makes a novel use of the
recent dichotomy for two-party protocols of <span class=blu1> Haitner et al. [ECCC '18]</span> to facilitate, for the two-party
case, the recent attack of <span class=blu1>  Beimel et al [ECCC '17]</span> on multi-party coin-flipping protocols.
</p>
</div>
</li>




<li>
Iftach Haitner  and <a href="http://omrier.wix.com/eran-omri">Eran Omri</a> and <a href="http://people.cs.georgetown.edu/~kobbi/">Kobbi Nissim</a> and  <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a> and  Jad Silbak<br>
<strong>Computational Two-Party Correlation</strong><br>
<span class=abslide>[abstract]</span> <br>
FOCS 2018<br>
Draft of full version <a href="papers/ComputationalCorrelation/ComputationalCorrelation.pdf">[pdf]</a><br><br>

<div class="box">
<p>
Consider an efficient two-party protocol that given security parameter <span class=blu2>k</span>,  both parties output
single bits <span class=blu2>X<sub>k</sub></span>  and <span class=blu2>Y<sub>k</sub></span>, respectively. We are interested in how <span class=blu2>(X<sub>k</sub>,Y<sub>k</sub>)</span> "appears" to an efficient
adversary that only views the transcript <span class=blu2>T<sub>k</sub></span>. We make the following contributions:<br><br>

<ul>  
<li> 
We develop new tools to argue about this loose notion, and show (modulo some caveats)
that for every such protocol there exists an efficient simulator such that the following holds: on input  <span class=blu2>T<sub>k</sub></span>, the simulator outputs a pair <span class=blu2>(X'<sub>k</sub>,Y'<sub>k</sub>)</span> 
such that <span class=blu2>(X'<sub>k</sub>,Y'<sub>k</sub>,T<sub>k</sub>)</span> 
is (somewhat) computationally indistinguishable from <span class=blu2>(X<sub>k</sub>,Y<sub>k</sub>,T<sub>k</sub>)</span>. 
</li> 
<br>
<li>
We use these tools to prove the following dichotomy theorem: every such protocol  is:

<ul>
<li> either uncorrelated:  it is (somewhat) indistinguishable from an effcient protocol
whose parties interact to produce transcript <span class=blu2>T<sub>k</sub></span>, but then choose their outputs independently from some product distribution (that is determined in poly-time from <span class=blu2>T<sub>k</sub></span>),

</li> 

<li>or, the protocol implies a key-agreement protocol (for infinitely  many <span class=blu2>k</span>'s). </li>

</ul> 
 <br>
 
 
Uncorrelated protocols are completely uninteresting from a cryptographic viewpoint, as
the correlation between outputs is uninteresting. Our dichotomy shows that every protocol
is either completely uninteresting or implies key-agreement.<br><br>

<li>  
We use the above dichotomy to make progress on open problems on minimal cryptographic
assumptions required for differentially private mechanisms for the XOR function.
</li> 

<li>
A subsequent work of Haitner et al. uses the above dichotomy to makes progress on a long-
standing open question regarding the complexity of fair two-party coin-flipping protocols.
</li>  
</ul> 
<br>
We highlight the following two ideas regarding our technique:<br>
<ul>
 <li>
 The simulator algorithm is obtained by a carefully designed "competition" between efficient algorithms attempting to forecast <span class=blu2>(X<sub>k</sub>,Y<sub>k</sub>)|<sub>T<sub>k</sub>=t</sub></span>. The winner is used to simulate the outputs of the protocol. To the best of our knowledge, this idea has not been used before (at least in this context).
</li> 
<li>
Our key-agreement protocol uses the simulation to reduce to an information theoretic
setup, and is in some sense non-black box.
</li> 
</ul> 





</p>
</div>
</li>




<li>
<a href="https://www.cs.bgu.ac.il/~beimel/">Amos Beimel </a> and Iftach Haitner and Nikolaos Makriyannis</a> and <a href="http://omrier.wix.com/eran-omri">Eran Omri</a> <br>
<strong>Tighter Bounds on Multi-Party Coin Flipping via
Augmented Weak Martingales and Differentially Private Sampling</strong><br>
<span class=abslide>[abstract]</span> <br>
FOCS 2018<br>
Draft of full version  <a href="papers/FairCoinLB/FairCoinLB.pdf">[pdf]</a><br><br>




<div class="box">
<p>
In his seminal work, <span class=blu1> Cleve [STOC 1986] </span>  has proved that any <span class=blu2> r</span>-round coin-flipping protocol
can be efficiently biassed by <span class=blu2> &Omega;(1/r)</span>. The above lower bound was met for the two-party case by
<span class=blu1> Moran, Naor, and Segev [Journal of Cryptology '16]</span>, and the three-party case (up to a polylog
factor) by <span class=blu1>  Haitner and Tsfadia [SICOMP '17]</span>, and was approached for <span class=blu2> n</span>-party protocols when <span class=blu2>n < loglog r </span> by Buchbinder, <span class=blu1> Haitner, Levi, and Tsfadia [SODA '17]</span>. For <span class=blu2> n > loglog r</span>, however,
the best bias for  <span class=blu2>n</span>-party coin-flipping protocols remains <span class=blu2> &Theta;(n/&radic;<span style="text-decoration:overline;">r</span>)</span> achieved by the majority
protocol of  <span class=blu1> Awerbuch, Blum, Chor, Goldwasser, and Micali [Manuscript '85]</span>.<br><br>

Our main result is a tighter lower bound on the bias of coin-flipping protocols, showing that, for every constant <span class=blu2> &epsilon; > 0</span>, an <span class=blu2> r<sup>&epsilon;</sup></span>-party <span class=blu2> r</span>-round coin-flipping protocol can be efficiently biased by <span class=blu2> &Omega;(1/&radic;<span style="text-decoration:overline;">r</span>)</span>. As far as we know, this is the first improvement of Cleve's bound that holds in the
standard model, and is only <span class=blu2> r<sup>&epsilon;</sup></span> (multiplicative) far from the aforementioned upper bound of <span class=blu1>  Awerbuch et al</span>.<br><br>


We  prove the above  bound using   two new results that we believe are of independent interest. 
The first result is that a sequence  of (``augmented'') weak martingales have large gap:  with constant probability there exists two adjacent variables whose gap
is  at least the ratio between the gap between the first and last variables and  the square root of the number of variables. 
This  generalizes over the  result of <span class=blu1> Cleve and Impagliazzo [Manuscript '93]</span>, who showed that the above holds for strong martingales, 
and allows in some setting to exploit this gap by efficient algorithms.  We prove the above using   a  novel argument  that does not follow the more complicated 
approach of  <span class=blu1> Cleve and Impagliazzo</span>. 
The second result is a new sampling algorithm  that uses a differentially private mechanism to minimize  the effect of data divergence.
</div>
</li>


<li>
<p>
<a href="https://people.csail.mit.edu/rancohen/">Ran Cohen</a> and Iftach Haitner and  <a href="http://omrier.wix.com/eran-omri">Eran Omri</a>  and Lior Rotem<br>
<strong>ï»¿From Fairness to Full Security in Multiparty Computation</strong> <br>
<span class=abslide>[abstract]</span><br>
SCN 2018  <a  href="https://link.springer.com/chapter/10.1007/978-3-319-98113-0_12">[link]</a><br>
</p>


<div class="box">
<p>
 ï»¿In the setting of secure multiparty computation (MPC), a set of mutually distrusting parties wish to jointly compute a function, while guaranteeing the privacy of their inputs and the correctness of the output. An MPC protocol is called \emph{fully secure} if no adversary can prevent the honest parties from obtaining their outputs. A protocol is called \emph{fair} if an adversary can prematurely abort the computation, however, only before learning any new information.

We present highly efficient transformations from fair computations to fully secure computations, assuming the fraction of honest parties is constant (e.g., $1\%$  of the parties are honest).
Compared to previous transformations that require linear invocations (in the number of parties) of the fair computation, our transformation require super-logarithmic, and sometimes even super-constant, such invocations.
The main idea is to delegate the computation to chosen random committees that invoke the fair computation. Apart from the benefit of uplifting security, the reduction in the number of parties is also useful, since only committee members are required to work, whereas the remaining parties simply ``listen'' to the computation over a broadcast channel.

One application of these transformations is a new $\delta$-bias coin-flipping protocol,  whose round complexity has a super-logarithmic dependency on the number of parties, improving over the protocol of Beimel, Omri, and Orlov (Crypto 2010) that has a linear dependency. A second application is a new fully secure protocol for computing the Boolean OR function, with a super-constant round complexity, improving over the protocol of Gordon and Katz (TCC 2009) whose round complexity is linear in the number of parties.

Finally, we show that our positive results are in a sense optimal, by proving that for some functionalities, a super-constant number of (sequential) invocations of the fair computation is necessary for computing the functionality in a fully secure manner.
 
 </p>
</div>
</li>



<li>
Iftach Haitner and <a href="http://www.eecs.harvard.edu/%7Esalil/"> Salil Vadhan </a> <br>
<strong>The Many Entropies in One-Way Functions</strong> <br>
<span class=abslide>[abstract]</span>   <a href="papers/ManyEntInOWF/ManyEntInOWF_SingleFile.pdf">[pdf]</a><br>
A chapter in <a href="https://link.springer.com/book/10.1007%2F978-3-319-57048-8">Tutorials on the Foundations of Cryptography</a> dedicated to <a href="http://www.wisdom.weizmann.ac.il/~oded/"> Oded Goldreich</a>  60th  birthday, 2017<br><br>



<div class="box">
<p>
Computational analogues of information-theoretic notions have given rise to some of the most interesting phenomena in the theory of computation.  For example, computational indistinguishability,    <span class=blu1>  Goldwasser and Micali [Journal of Computer and System Sciences 1984] </span>, which is the computational analogue of statistical distance,  enabled the bypassing of Shanon's impossibility results on perfectly secure encryption, and provided the basis for the computational theory of pseudorandomness. 
Pseudoentropy,  <span class=blu1> Haastad, Impagliazzo, Levin, and Luby [SICOMP 1999]</span>, a computational analogue of entropy, was the key to the fundamental result establishing the equivalence of pseudorandom generators and one-way functions, and has become a basic concept in complexity theory and cryptography. 

This tutorial discusses  two rather recent computational notions  of entropy, both  of which can be easily found in any  one-way function,  the most basic cryptographic primitive. The first notion is next-block pseudoentropy,  <span class=blu1> Haitner, Reingold and Vadhan [SICOMP 2013]</span>, a refinement of  of pseudoentropy that  enables simpler and more  efficient construction of pseudorandom generators.  The second is inaccessible entropy, <span class=blu1> Haitner, Reingold, Vadhan and Wee [STOC 2009]</span>, which relates to unforgeability and is used to construct simpler and more efficient universal one-way hash functions and statistically hiding commitments.
</p>
</div>
</li>

<li>
<a href="http://www.tau.ac.il/~nivb/">Niv Buchbinder</a>  and Iftach Haitner and Nissan Levi and Eliad Tsfadia <br>
<strong>Fair Coin Flipping: Tighter Analysis and the Many-Party Case</strong> <br>
<span class=abslide>[abstract]</span>  <!-- <a href="papers/3PartyCF/ManyPartySeminar.ppsx">[slides]</a> --> <br>
SODA 2017 <br>
Draft of full version <a href="papers/3PartyCF/ManyPartyCF_Full.pdf">[pdf]</a> 


<!-- <img src="up.png" class=update1>  -->
<div class="box">
<p>
In a multi-party  fair coin-flipping protocol, the parties output a common (close to) unbiased  bit, even when some corrupted parties try to bias the output. 
In this work we focus on the case of arbitrary number of corrupted parties.  <span class=blu1> Cleve [STOC 1986] </span> has shown that in <b> any</b> such <span class=blu2>m</span>-round coin-flipping protocol, the corrupted parties can bias the honest parties' 
common output bit  by <span class=blu2> &Omega;(1/m)</span>. For more than two decades, however,  the best known coin-flipping protocol was the one of <span class=blu1> Awerbuch, Blum, Chor, Goldwasser, and Micali [Manuscript 1985]</span>, who presented a <span class=blu2>t</span>-party, <span class=blu2>m</span>-round  protocol with bias  
<span class=blu2> &Theta;(t/&radic;<span style="text-decoration:overline;">m</span>)</span>. This was changed by a recent breakthrough result of <span class=blu1> Moran et al. [TCC 2009]</span>,
who constructed an <span class=blu2>m</span>-round, two-party coin-flipping protocol with optimal bias <span class=blu2>&Theta;(1/m)</span>. 
Recently, <span class=blu1> Haitner and Tsfadia [STOC 14] </span>  constructed an <span class=blu2>m</span>-round, three-party coin-flipping protocol with  bias  <span class=blu2> O((log  m)<sup>3</sup>/m</span>. 
Still for the case of more than three parties,  the best known protocol remained the <span class=blu2> &Theta;(t/&radic;<span style="text-decoration:overline;">m</span>)</span>-bias protocol of <span class=blu1> Awerbuch et al</span>.

<br>
We make a step towards eliminating the above gap, presenting a <span class=blu2>t</span>-party,  <span class=blu2>m</span>-round coin-flipping protocol, 
with bias <span class=blu2>O(t^3 * 2<sup>t</sup> * &radic;<span style="text-decoration:overline;">log m</span>/ m<sup>.5 + 1/(2<sup>t-1</sup>-2)</sup>)</span>.
 This improves upon the  protocol of <span class=blu1> Awerbuch et al.</span> for any <span class=blu2>t< loglog m /2</span>, and in particular for <span class=blu2>t &#8712 O(1)</span>,  it is a <span class=blu2>1/m<sup>.5+ &Theta;(1)</sup></span>-bias protocol. For the three-party case, 
is is a <span class=blu2> O(&radic;<span style="text-decoration:overline;">log m</span>/m)</span>-bias protocol,  improving over the protocol  of  <span class=blu1> Haitner and Tsfadia </span>.  
<br>

Our protocol generalizes that of  <span class=blu1> Haitner and Tsfadia </span> 
by presenting an appropriate ``defense protocols'' for the remaining parties to interact in, in the case that some parties abort or caught cheating. 
We analyze  the new protocols by  presenting  a new paradigm for analyzing fairness of coin-flipping protocols. We map the set of adversarial strategies that try to bias the honest parties outcome in the protocol to the set of the feasible solutions of a linear program. The gain each strategy achieves is the value of the corresponding solution. We then bound the the optimal value of the linear program by constructing a feasible solution to its dual.

</p>
</div>
</li>


<li>
<p>
<a href="http://www.cs.tau.ac.il/~cohenran/">Ran Cohen</a> and Iftach Haitner and  <a href="http://omrier.wix.com/eran-omri">Eran Omri</a>  and Lior Rotem<br>
<strong>Characterization of Secure Multiparty Computation Without Broadcast </strong> <br>
<span class=abslide>[abstract]</span><br>
TCC 2016-A <a  href="http://link.springer.com/chapter/10.1007/978-3-662-49096-9_25">[link]</a><br>
Journal of Cryptology 2017 <a  href="http://rdcu.be/v7wO">[link]</a><br>
</p>


<div class="box">
<p>
 A major challenge in the study of cryptography is characterizing the necessary and sufficient assumptions required to carry out a given cryptographic task. The focus of this work is the necessity of a broadcast channel for securely computing symmetric functionalities (where all the parties receive the same output) when one third of the parties, or more, might be corrupted. Assuming all parties are connected via a peer-to-peer network, but no broadcast channel (nor a secure setup phase) is available, we prove the following characterization:<br>

 <ul>
 <li>
    A symmetric <span class=blu2>n</span>-party functionality can be securely computed facing <span class=blu2> n/3 &#8804 t &#60 n/2</span>  corruptions (i.e., honest majority), if and only if it is <em><span class=blu2>(n-2t)</span>-dominated</em> a functionality is <span class=blu2>k</span>-dominated, if <em>any</em> <span class=blu2>k</span>-size subset of its input variables can be set to <em>determine</em> its output.
 </li> 	
  	
	
<li>	
    Assuming the existence of one-way functions, a symmetric <span class=blu2>n</span>-party functionality can be securely computed facing <br><span class=blu2>t &#8805 n/2</span> corruptions (i.e., no honest majority), if and only if it is <span class=blu2>1</span>-dominated and can be securely computed with broadcast.
 </li> 	
</ul>
  It follows that, in case a third of the parties might be corrupted, broadcast is necessary for securely computing non-dominated functionalities (in which ``small'' subsets of the inputs cannot determine the output), including, as interesting special cases, the Boolean XOR and coin-flipping functionalities.
</p>
</div>
</li>




<li>
<p>
Iftach Haitner and  <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a> and <a href="http://omrier.wix.com/eran-omri">Eran Omri</a>  and   <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
<strong>Parallel Hashing via List Recoverability</strong> <br>
<span class=abslide>[abstract]</span><br>
Crypto 2015  <a href="https://link.springer.com/chapter/10.1007/978-3-662-48000-7_9">[link]</a><br>
<!-- !Draft of full version  <a href="papers/CRHDomainExtension/CRH_Crypto.pdf">[pdf]</a><br> -->
</p>


<div class="box">
<p>
Motivated by the goal of constructing efficient hash functions, we investigate the possibility of hashing a long message by only making parallel,
non-adaptive calls to a hash function on short messages. Our main result is a simple construction of a collision-resistant hash function <span class=blu2>h:{0,1}<sup>k</sup> <td>&#8594;</td> {0,1}<sup>k</sup> </span> that makes a polynomial number of parallel calls to a \emph{random} function <span class=blu2> f:{0,1}<sup>k</sup> <td>&#8594;</td> {0,1}<sup>k</sup> </span>, for any polynomial <span class=blu2> n=n(k) </span>.  This should be compared with the traditional use of a Merkle hash tree, that  requires at least <span class=blu2> log(n/k)</span> rounds of calls to <span class=blu2>f</span>, and with a more complex construction of  <span class=blu1> Maurer and Tessaro (Crypto 2007)</span> that requires two rounds of calls to  <span class=blu2>f</span>. We also show that our hash function  <span class=blu2>h</span> satisfies a relaxed form of the notion of indifferentiability of  <span class=blu1> Maurer et al. (TCC 2004)</span> that suffices for implementing the Fiat-Shamir paradigm. As a corollary, we get sublinear-communication non-interactive arguments for NP that only make two rounds of calls to a small random oracle.

An attractive feature of our construction is that  <span class=blu2>h</span> can be implemented by boolean circuits that only contain parity gates in addition to the parallel calls to  <span class=blu2>f</span>. Thus, we get the first domain-extension scheme which is   <em>degree-preserving</em> in the sense that the algebraic degree of  <span class=blu2>h</span> over the binary field is equal to that of  <span class=blu2>f</span>

Our construction makes use of <em>list-recoverable codes</em>, a generalization of list-decodable codes that is closely related to the notion of randomness condensers. We show that list-recoverable codes are necessary for any construction of this type.
</p>
</div>




<li>
<p><a name="HHRSJoint"></a> 
Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>
and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<strong>Finding Collisions in Interactive Protocols â€” Tight Lower Bounds on the Round Complexity and Communication Complexityof Statistically Hiding Commitments </strong>
<br>
<span class=abslide>[abstract]</span><br>
SIAM Journal of Computing 2015 <a  href="http://epubs.siam.org/doi/abs/10.1137/130938438">[link]</a><br>

Draft of full version <a href="papers/FindingCollisions/FindingCollisions_Joint.pdf"> [pdf]</a>  
</p>


<div class="box" >
<p>
We study the round complexity and communication complexity of various cryptographic protocols. We give tight lower bounds on the 
round complexity and communication complexity of any fully black-box reduction of a statistically hiding commitment scheme from one-way
permutations, and from trapdoor permutations. As a corollary, we derive  similar tight lower bounds for several other cryptographic protocols,
such as single-server private information retrieval, interactive hashing, and oblivious transfer that guarantees statistical security
for one of the parties. Our techniques extend the collision-finding oracle due to <span class=blu1>Simon [EUROCRYPT 98] </span> to the setting of interactive protocols, 
and the reconstruction paradigm of

In their seminal work, Impagliazzo and Rudich (STOCâ€™89) showed that no key-agreement protocol exists in the random-oracle model, yielding that key agreement cannot be black-box reduced to one-way functions. In this work, we generalize their result, showing that, to a large extent, no-private-input, semi-honest, two-party functionalities that can be securely implemented in the random oracle model can be securely implemented information theoretically (where parties are assumed to be all powerful, and no oracle is given). Using a recent information-theoretic impossibility result by McGregor et al. (FOCSâ€™10), our result yields that certain functionalities (e.g. inner product) cannot be computed both in an accurately and in a differentially private manner in the random oracle model, implying that protocols for computing these functionalities cannot be black-box reduced to the existence of one-way functions.
Gennaro and Trevisan [FOCS 00]</span>.
</p>
</div>
</li>

<li>
<p>
<a href="http://people.csail.mit.edu/itayberm/">Itay Berman</a> and Iftach Haitner and  <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>Coin Flipping of Any Constant Bias Implies One-Way Functions </strong> <br>
<span class=abslide>[abstract]</span>&nbsp<a href="papers/TightCF/TightCoinFlipping_full.ppsx">[slides]</a><br>
STOC 2014<br>
Journal of the ACM 2018 <a href="https://dl.acm.org/citation.cfm?id=3191817.2979676">[link]</a><br>
Draft of full version <a href="papers/TightCF/TCoingFlip_F.pdf">[pdf]</a> 

</p>


<div class="box">
<p>
We show that the existence of a coin-flipping protocol safe against any non-trivial constant bias (e.g., <span class=blu2>.499</span>), implies the
existence of one way functions. This improves upon a recent result of <span class=blu1>Haitner and Omri [FOCS â€™11]</span> ,
who proved this implication for protocols with bias <span class=blu2>&radic;<span style="text-decoration:overline;">2</span>âˆ’ <sup>1</sup>â„<sub>2</sub>&nbsp;~.207</span>. Unlike the result of
Haitner and Omri, our result holds also for <em>weak</em> coin-flipping protocols.
</p>
</div>
</li>

<li>
Iftach Haitner and Eliad Tsfadia <br>
<strong>An Almost-Optimally Fair Three-Party Coin-Flipping Protocol</strong><br>
<span class=abslide>[abstract]</span> <a href="papers/3PartyCF/3Party-full.ppsx">[slides]</a> <br>
STOC 2014 <a href="papers/3PartyCF/QuasiOptimalCF_CR.pdf">[pdf]</a><br>
SIAM Journal of Computing 2017 <a href="http://epubs.siam.org/doi/abs/10.1137/15M1009147">[link]</a>   <br>
Draft of full version <a href="papers/3PartyCF/QuasiOptimalCF_Full.pdf">[pdf]</a> <br><br>



<div class="box">
<p>
In a multiparty, fair coin-flipping protocol, the parties output a common (close to) unbiased bit, even when some  corrupted parties try to bias the output.
<span class=blu1> Cleve [STOC 1986] </span> has shown that in the case of dishonest
majority (i.e., at least half of the parties can be corrupted), the  corrupted parties can bias the honest parties common output bit
by  <span class=blu2> &Omega;(1/m)</span>, in any m-round, coin-flipping protocol. For more than two decades, however, the best known
coin-flipping protocols had bias <span class=blu2> &Theta;(t/&radic;<span style="text-decoration:overline;">m</span>)</span> 
against dishonest majority, where <span class=blu2>t</span> is the number of
corrupted parties. This was changed by a recent breakthrough result of <span class=blu1> Moran et al. [TCC 2009]</span>,
who constructed an <span class=blu2>m</span>-round,
two-party coin-flipping protocol with optimal bias <span class=blu2>&Theta;(1/m)</span>. Where in a
subsequent work, <span class=blu1> Beimel et al. [Crypto 2010]</span> extended this result for the multiparty
case, in which less than  <span class=blu2> <sup>2</sup>â„<sub>3</sub></span> of case, in which less than  <span class=blu2> <sup>2</sup>â„<sub>3</sub></span> of
the parties can be corrupted. More specifically, for any <span class=blu2> t &lt; <sup>2</sup>â„<sub>3</sub>
Â· k </span>, they presented an <span class=blu2>m</span>-round, <span class=blu2>k</span>-party
protocol, with bias <span class=blu2>&Theta;( 2<sup>2tâˆ’k</sup>/m)</span> against (up to) <span class=blu2>t</span>
corrupted parties. Still for the case  <span class=blu2> <sup>2</sup>â„<sub>3</sub></span>
(or more) corrupted parties, the best known protocol had bias <span class=blu2> &Theta;(t/&radic;<span style="text-decoration:overline;">m</span>)</span>. In particular,
this was the state of affairs for the natural three-party case (against
two corrupted parties).<br>
<br>
We make a step towards eliminating the above gap, presenting an m-round, three-party,
coin-flipping protocol, with bias <span class=blu2> O(log 3 m)/m</span>. Our approach (which we also apply for the two-party case), does not
follow the â€œthreshold roundâ€ paradigm used in the work of Moran et al. and Beimel et al.,
but rather is a takeoff of the majority protocol of Cleve (used to obtain the <span class=blu2> &Theta;(&radic;<span style="text-decoration:overline;">t</span>)</span>-bias protocol,
mentioned above).
</p>
</div>
</li>



<li>
Iftach Haitner and <a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a> and <a href="http://u.cs.biu.ac.il/%7Ezarosih/">Hila Zarosim</a><br>
<strong>Limits on the Usefulness of Random Oracles</strong> <br>
<span class=abslide>[abstract]</span><br>
TCC 2013 <a href="papers/PowerofRO1/PowerOfRO_TCC.pdf">[pdf]</a><br>
Journal of Cryptology 2014  <a  href="http://link.springer.com/article/10.1007/s00145-014-9194-9?sa_campaign=email/event/articleAuthor/onlineFirst">[link]</a><br>
Draft of full version  <a href="papers/PowerofRO1/PowerOfRO.pdf">[pdf]</a></p>
<div class="box">
In their seminal work, <span class=blu1>Impagliazzo and Rudich [STOCâ€™89]</span> showed that no key-agreement protocol exists in the random-oracle model,
yielding that key agreement cannot be black-box reduced to one-way functions. 
In this work, we generalize their result, showing that, to a large extent, no-private-input, semi-honest, two-party functionalities that can
be securely implemented in the random oracle model can be securely implemented information theoretically (where parties are assumed to be all powerful, 
and no oracle is given). Using a recent information-theoretic impossibility result by <span class=blu1> McGregor et al. [FOCSâ€™10]</span>, 
our result yields that certain functionalities (e.g. inner product) cannot be computed both in an accurately and in a differentially private manner in the 
random oracle model,  implying that protocols for computing these functionalities cannot be black-box reduced to the existence of one-way functions.
</div>
</li>


<li>
<p><a href="http://people.csail.mit.edu/itayberm/">Itay Berman</a> and Iftach Haitner and 
<a href="https://sites.google.com/site/ilankomhomepage/"> Ilan Komargodski</a> and <a href="http://www.wisdom.weizmann.ac.il/%7Enaor/">Moni Naor</a><br>
<strong>Hardness Preserving Reductions via Cuckoo Hashing </strong><br> 
<span class=abslide>[abstract]</span><br>
TCC 2013 <a href="papers/Cuckoo/Cuckoo_TCC.pdf">[pdf]</a><br>
Journal of Cryptology 2018 <a href="https://link.springer.com/article/10.1007/s00145-018-9293-0">[link]</a></p>

<div class="box">
A common method for increasing the usability and uplifting the security of pseudorandom function families (PRFs) is to â€œhashâ€ the inputs into a
smaller domain before applying the PRF. This approach, known as â€œLevinâ€™s trickâ€, is used to achieve â€œPRF domain extensionâ€ (using a short, e.g., fixed, input length PRF to get a
variable-length PRF), and more recently to transform non-adaptive PRFs to adaptive ones. Such reductions, however, are
vulnerable to a â€œbirthday attackâ€: after <span class=blu2> &Theta;(&radic;<span style="text-decoration:overline;">|U|</span>)</span> 
queries to the resulting PRF, where <span class=blu2>U</span> being the hash function range, a collision 
(i.e., two distinct inputs have the same hash value) happens with high probability. As a consequence, the resulting PRF is insecure
against an attacker making this number of queries.<br>

In this work we show how to go beyond the birthday attack barrier, by
replacing the above simple hashing approach with a variant of <strong>cuckoo
hashing</strong> â€” a hashing paradigm typically used for resolving hash collisions in a table, by using two hash functions
and two tables and cleverly assigning each element into one of the two tables. We use this approach to obtain:<br>
(i) A domain extension method that requires <strong>just two calls</strong> to the original PRF, can withstand as many queries
as the original domain size and has a distinguishing probability that
is exponentially small in the non cryptographic work.<br>
(ii) A <strong>security-preserving</strong> reduction from non-adaptive to adaptive PRFs.
</div>
</li>



<li>
<p>
 <a href="http://people.csail.mit.edu/itayberm/">Itay Berman</a> and Iftach Haitner<br>
<strong>From Non-Adaptive to Adaptive Pseudorandom Functions</strong><br>
<span class=abslide>[abstract]</span><br>
Journal of Cryptology 2013  <a  href="http://link.springer.com/article/10.1007/s00145-013-9169-2">[link]</a><br>
TCC 2012 <a href="papers/AdaptivePRF/AdaptivePRF_TCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/AdaptivePRF/AdaptivePRF.pdf">[pdf]</a>
</p>

<div class="box"  >
Unlike the standard notion of pseudorandom functions (PRF), a <strong> non-adaptive</strong> PRF 
is only required to be indistinguishable from a random function in the eyes of a <strong>non-adaptive</strong>
distinguisher (i.e., one that prepares its oracle calls in advance). A recent line of research has studied the possibility of a <strong>direct</strong>
construction of adaptive PRFs from non-adaptive ones, where direct means that the constructed adaptive PRF uses only few (ideally,
constant number of) calls to the underlying non-adaptive PRF. Unfortunately, this study has only yielded negative results, showing
that ``natural" such constructions are unlikely to exist (e.g., <span class=blu1> Myers [EUROCRYPT '04], Pietrzak [CRYPTO '05, EUROCRYPT '06]</span>).<br>
<br>
We give an affirmative answer to the above question, presenting a direct construction of adaptive PRFs from non-adaptive ones. The
suggested construction is extremely simple, a composition of the non-adaptive PRF with an appropriate pairwise independent hash
function.
</div>
</li>

<li>
<p>
Iftach Haitner and <a href="http://u.cs.biu.ac.il/%7Eomrier/">Eran Omri</a><br>
<strong>Coin Flipping with Constant Bias ImpliesOne-Way Functions</strong><br>
<span class=abslide>[abstract]</span>&nbsp <a href="papers/CoinFlipping/Seminar.pptx">[slides]</a><br>
SIAM Journal of Computing 2013   <a  href="http://epubs.siam.org/doi/abs/10.1137/120887631">[link]</a> <br>
FOCS 2011 <a href="papers/CoinFlipping/CoinFlippingtoOWF_FOCS.pdf">[pdf]</a><br>
Draft of full version <a href="papers/CoinFlipping/CoinFlippingtoOWF.pdf">[pdf]</a></p>

<div class="box">
<p>
It is well known (c.f., <span class=blu1> Impagliazzo and Luby [FOCS '89]</span>) that the existence
of almost all ``interesting" cryptographic applications, i.e., ones that cannot hold information theoretically, implies one-way functions.
An important exception where the above implication is not known, however, is the case of coin-flipping protocols. Such protocols allow
honest parties to mutually flip an unbiased coin, while guaranteeing that even a cheating (efficient) party cannot bias the output of the
protocol by much. While Impagliazzo and Luby proved that coin-flipping protocols that are safe against negligible bias do imply one-way
functions, and, very recently, <span class=blu1> Maji, Prabhakaran, and Sahai [FOCS '10]</span>
proved the same for constant-round protocols (with any non-trivial bias). For the general case, however, no such implication was known.
<br>
We make progress towards answering the above fundamental question, showing that (strong) coin-flipping protocols safe against a constant
bias (concretely,<span class=blu2>&radic;<span style="text-decoration:overline;">2</span>âˆ’ <sup>1</sup>â„<sub>2</sub>&nbsp;~.207</span>) imply one-way functions.
</p>

</div>
</li>

<li>
<p>
Iftach Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a> and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
<b>Efficiency Improvements in Constructing Pseudorandom Generators from One-way Functions</b><br>
<span class=abslide>[abstract]</span> <a href="papers/HillRevisted/HillRevisted_Full.pptx">[slides]</a> <br>

SIAM Journal of Computing 2013    <a  href="http://epubs.siam.org/doi/abs/10.1137/100814421">[link]</a><br>
Annual ACM Symposium on Theory of Computing (STOC), 2010  <a href="papers/HillRevisted/HillRevisted_STOC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/HillRevisted/HillRevisted_Full.pdf">[pdf]</a>
</p>

<div class="box" >
<p>
We give a new construction of pseudorandom generators from any one-way
function. The construction achieves better parameters and is simpler
than that given in the seminal work of <span class=blu1> HÃ¥stad, Impagliazzo, Levin and Luby [SICOMP '99]</span>. 
The key to our construction is a new notion of <strong>next-block pseudoentropy</strong>, which is inspired by the notion of
``inaccessible entropy'' recently introduced in <span class=blu1> Haitner, Reingold,Vadhan and Wee [STOC '09]</span>. An additional advantage over all previous
constructions is that our pseudorandom generators are highly parallelizable and invoke the one-way function in a non-adaptive
manner. Using <span class=blu1>Applebaum, Ishai and Kushilevitz [SICOMP '06]</span>, this implies the existence of pseudorandom generators in 
<span class=blu2>NC<sup>0</sup></span> based on the existence of one-way functions in <span class=blu2>NC<sup>1</sup></span>.
</p>
</div>
</li>


<li>
<p>
Iftach Haitner<br>
<strong>A Parallel Repetition Theorem for Any Interactive Argument </strong><br>
<span class=abslide>[abstract]</span> <a href="papers/ArgumentPR/Seminar.pptx">[slides]</a> <br>
SIAM Journal of Computing 2013   <a  href="http://epubs.siam.org/doi/abs/10.1137/100810630">[link]</a><br>
IEEE Symposium on Foundations of Computer Science (FOCS), 2009<br>
Draft of full version <a href="papers/ArgumentPR/ArgumentPR.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
The question whether or not parallel repetition reduces the soundness error is a fundamental question in the theory of protocols. 
While parallel repetition reduces (at an exponential rate) the error in interactive proofs and (at a weak exponential rate) in special cases of interactive
arguments (e.g., 3-message protocols - <span class=blu1>Bellare, Impagliazzo and Naor [FOCS '97]</span>, and 
public-coin protocols - <span class=blu1>HÃ¥stad, Pass, Pietrzak and
WikstrÃ„om [TCC '10])</span>, Bellare et. al gave example of interactive arguments for which parallel repetition does not reduce the soundness
error at <strong>all</strong>.<br>

We show that by slightly modifying  <em>any</em> interactive argument, in a way that preserves its completeness and only
slightly deteriorates its soundness, we get a protocol for which parallel repetition does reduce the error at a weak exponential rate.
In this modified version, the verifier flips at the beginning of each round an <span class=blu2>(1 - (1/4m), 1/4m)</span> biased
coin (i.e., <span class=blu2>1</span> is tossed with probability <span class=blu2>1/4m</span>), where <span class=blu2>m</span> is the round complexity of the
(original) protocol. If the coin is one, the verifier halts the interaction and accepts, otherwise it sends the same message that the
original verifier would. At the end of the protocol (if reached), the
verifier accepts if and only if the original verifier would.
</p>
</div>
</li>

<li>
<p> 
<a href="http://www.cs.nyu.edu/%7Edodis/">Yevgeniy Dodis</a>, Iftach Haitner and <a href="http://cs.nyu.edu/%7Etentes/Homepage.html">Aris Tentes</a><br>
<strong>On the Instantiability of Hash-and-Sign RSA Signatures</strong><br> 
<span class=abslide>[abstract]</span> <a href="papers/FullDomainHash/seminar.pptx">[slides]</a><br>
TCC 2012 <a href="papers/FullDomainHash/FDH_TCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/FullDomainHash/FDH.pdf">[pdf]</a>
</p>

<div class="box"  >
<p> 
The hash-and-sign RSA signature is one of the most elegant and well known signatures schemes, extensively used in a wide variety of cryptographic
applications. Unfortunately, the only existing analysis of this popular signature scheme is in the random oracle model, where the resulting
idealized signature is known as the <em>RSA Full Domain Hash</em> signature scheme (RSA-FDH). In fact, prior work has shown several
``uninstantiability'' results for various abstractions of RSA-FDH, where the RSA function was replaced by a family of trapdoor random
permutations, or the hash function instantiating the random oracle could not be keyed. These abstractions, however, do not allow the
reduction and the hash function instantiation to use the algebraic properties of RSA function, such as the multiplicative group structure
of <span class=blu2>Z<sub>n</sub>*</span>. In contrast, the multiplicative property of
the RSA function is critically used in many standard model analyses of various RSA-based schemes.<br>

Motivated by closing this gap, we consider the setting where the RSA function representation is generic (i.e., black-box) <strong>but
multiplicative</strong>, whereas the hash function itself is in the standard model, and can be keyed and exploit the multiplicative properties of
the RSA function. This setting abstracts all known techniques for designing provably secure RSA-based signatures in the standard model, and aims to address
the main limitations of prior uninstantiability results. Unfortunately, we show that it is still impossible to reduce the
security of RSA-FDH to any natural assumption even in our model. Thus, our result suggests that in order to prove the security of a given instantiation
of RSA-FDH, one should use a non-black box security proof, or use specific properties of the RSA group
that are not captured by its multiplicative structure alone.<br>

We complement our negative result with a positive result, showing that the RSA-FDH signatures <strong>can</strong> be proven
secure under the <strong>standard</strong> RSA assumption, provided that the number of signing queries is <strong>a-priori bounded</strong>.
</p> 
</div>
</li>


<li>
<p><a name="BBMPC"></a> 
Iftach Haitner, <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a>, <a href="http://www.cs.technion.ac.il/%7Eeyalk/">Eyal
Kushilevitz</a>, <a href="http://u.cs.biu.ac.il/%7Elindell//">Yehuda Lindell</a> and <a href="http://www.cs.technion.ac.il/%7Eerez/">Erez Petrank</a><br>
<strong>Black-Box Constructions of Protocols for Secure Computation</strong><br>
<span class=abslide>[abstract]</span><br>
SIAM Journal of Computing 2011 <a  href="http://epubs.siam.org/doi/abs/10.1137/080721820">[link]</a><br>
Draft of full version <a href="papers/BlackBoxMPC/black-box-mpc.pdf">[pdf]</a>
</p>

<div class="box" >
<p>
It is well known that secure computation without an honest majority requires computational assumptions. An interesting question that
therefore arises relates to the way such computational assumptions are used. Specifically, can the secure protocol use the underlying
primitive (e.g., a one-way trapdoor permutation) in a black-box way, treating it as an oracle, or must it be non-black-box (by referring to
the code that computes the primitive)? <br>
Despite the fact that many general constructions of cryptographic
schemes refer to the underlying primitive in a black-box way only,
there are some constructions that are inherently nonblack-box. Indeed,
all known constructions of protocols for general secure computation
that are secure in the presence of a malicious adversary and without an
honest majority use the underlying primitive in a nonblack-box way
(requiring to prove in zero-knowledge statements that relate to the
primitive).<br>
In this paper, we study whether such nonblack-box use is essential. We
answer this question in the negative. Concretely, we present a fully
black-box reduction from oblivious transfer with security against
malicious parties to oblivious transfer with security against
semi-honest parties. As a corollary, we get the first constructions of
general multiparty protocols (with security against malicious
adversaries and without an honest majority) which only make a black-box
use of semi-honest oblivious transfer, or alternatively a black-box use
of lower-level primitives such as enhanced trapdoor permutations or
homomorphic encryption. 
</p>
</div>
</li>




<li>
<p>
<a href="http://www.cs.princeton.edu/%7Eboaz/">Boaz Barak</a>, Iftach Haitner, <a href="http://homepages.cwi.nl/%7Ehofheinz/">Dennis Hofheinz</a>
and <a href="http://www.cs.technion.ac.il/%7Eyuvali/">Yuval Ishai</a><br>
<strong>Bounded Key-Dependent Message Security</strong><br>
<span class=abslide>[abstract]</span><br>
Advances in Cryptology - Eurocrypt, 2010 <a href="papers/BoundedKDM/boundedkdm_EuroCrypt.pdf">[pdf]</a><br>
Draft of full version <a href="papers/BoundedKDM/boundedkdm.pdf">[pdf]</a>
</p>


<div class="box" >
<p>
We construct the first public-key encryption scheme that is proven secure
(in the standard model, under standard assumptions) even when the attacker gets access to encryptions of arbitrary efficient functions of the secret key.
Specifically, under either the DDH or LWE assumption, for every polynomials <span class=blu2>L</span> and <span class=blu2>N</span> we obtain a
public-key encryption scheme that resists key-dependent message (KDM) attacks for up to <span class=blu2>N(k)</span>
public keys and functions <strong>circuit size</strong> up to <span class=blu2>L(k)</span>, where <span class=blu2>k</span> denotes the size of the secret
key. We call such a scheme <strong>bounded KDM secure</strong>. Moreover, we show that our scheme suffices for
one of the important applications of KDM security: ability to securely instantiate symbolic protocols with
axiomatic proofs of security.<br>

We also observe that any fully homomorphic encryption scheme which
additionally enjoys circular security and circuit privacy is <strong>fully KDM secure</strong> in the sense that the encryption and
decryption algorithms can be independent of the polynomials <span class=blu2>L</span> and <span class=blu2>N</span> as
above. Thus, the recent fully homomorphic encryption scheme of <span class=blu1>Gentry [STOC 2009]</span> is fully KDM
secure under certain non-standard hardness assumptions. Previous works obtained either full KDM security in the random oracle
model (<span class=blu1> Black et al. [SAC 2002]</span>) or security with respect to a very restricted
class of functions (e.g., clique/circular security and affine functions, <span class=blu1> Boneh et al. [CRYPTO 2008]</span> and 
<span class=blu1> Applebaum et al. [CRYPTO 2009]</span>.<br>
Our main result is based on a combination of the circular-secure
encryption scheme of either Boneh et al. <strong>or</strong> Applebaum et al. with
Yao's garbled circuit construction.<br>
Finally, we extend the impossibility result of <span class=blu1> Haitner and Holenstein [TCC 2009]</span>, showing that it
is impossible to prove KDM security against a family of query functions that contains exponentially hard pseudorandom functions, 
using only <strong>black-box</strong> access to the query function and the adversary attacking the scheme. This proves that the non-black-box
usage of the query function in our proof of security makes to the KDM query function is <strong>inherent</strong>.
</p>
</div>
</li>

<li>
<p>
Iftach Haitner, <a href="http://research.microsoft.com/users/thomahol/">Thomas Holenstein</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer
Reingold</a>, <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
<b>Universal One-Way Hash Functions via Inaccessible Entropy </b><br>
<span class=abslide>[abstract]</span><br>
Advances in Cryptology - Eurocrypt, 2010 <a href="papers/RompelRevisted/RompelRevisited-EurocryptCamera.pdf">[pdf]</a><br>
Draft of full version <a href="papers/RompelRevisted/RompelRevisited-eprint.pdf">[pdf]</a>
</p>


<div class="box">
<p>
This paper revisits the construction of Universally One-Way Hash Functions (UOWHFs) from any one-way function due to <span class=blu1> Rompel [STOC 1990}</span>.
We give a simpler construction of UOWHFs which also obtains better efficiency and security. The construction exploits a strong connection to the recently
introduced notion of <strong>inaccessible entropy</strong> <span class=blu1> Haitner et
al. [STOC 2009]</span>. With this perspective, we observe that a small tweak of
any one-way function <span class=blu2> f</span> is already a weak form of a UOWHF: Consider
<span class=blu2> F(x,i)</span> that outputs the <span class=blu2>i</span>-bit long
prefix of <span class=blu2>f(x)</span>. If <span class=blu2>F</span> were a UOWHF then given a
random <span class=blu2>x</span> and i it would be hard to come up with <span class=blu2>x' â‰  x</span> such
that <span class=blu2>F(x,i)=F(x',i)</span>. While this may not be the case, we show (rather easily) that it is hard
to sample <span class=blu2>x'</span> with almost full entropy among all the possible such values of <span class=blu2>x'</span>. The rest of our construction
simply amplifies and exploits this basic property.<br>
With this and other recent works we have that the constructions of
three fundamental cryptographic primitives (Pseudorandom Generators,
Statistically Hiding Commitments and UOWHFs) out of one-way functions
are to a large extent unified. In particular, all three constructions
rely on and manipulate computational notions of entropy in similar
ways. Pseudorandom Generators rely on the well-established notion of
pseudoentropy, whereas Statistically Hiding Commitments and UOWHFs rely
on the newer notion of inaccessible entropy.
</p>
</div>
</li>


<li>
<p>
Iftach Haitner,  <a href="http://www.cs.princeton.edu/%7Emohammad/">Mohammad Mahmoody</a> and <a href="http://www.cs.princeton.edu/%7Edxiao/"> David Xiao</a><br>
<strong>New Sampling Protocol and Applications to Basing Cryptographic Primitives on the Hardness of NP</strong><br>
<span class=abslide>[abstract]</span> <br>
IEEE Conference on Computational Complexity (CCC), 2010 <a href="papers/SampleWithSize/SampleWithSize_CCC.pdf">[pdf]</a><br>
Draft of full version <a href="papers/SampleWithSize/SampleWithSize.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
We investigate the question of what languages can be decided efficiently with the help of a recursive collision-finding oracle. Such an oracle can be used to break
collision-resistant hash functions or, more generally, statistically hiding commitments. The
oracle we consider <span class=blu2>Sam<sub>d,</sub></span> where <span class=blu2>d</span> is the
recursion depth, is based on the identically-named oracle defined in the work of
<span class=blu1>Haitner et al. (FOCS '07)</span>. Our main result is a constant-round public-coin protocol <span class=blu2>AM-Sam</span>
that allows an efficient verifier to emulate a <span class=blu2>Sam<sub>d</sub></span>
oracle for any constant depth <span class=blu2>d = O(1)</span> with the help of a <span class=blu2>BPP<sup>NP</sup></span>
prover. <span class=blu2> AM-Sam</span> allows us to conclude that if <span class=blu2>L</span>
is decidable by a <span class=blu2>k</span>-adaptive randomized oracle algorithm with access to a <span class=blu2>Sam<sub>O(1)</sub></span>
oracle, then <span class=blu2>LâˆˆAM[k]âˆ©coAM[k]</span>.<br>

The above yields the following corollary: assume there exists an
<span class=blu2>O(1)</span>-adaptive reduction that bases constant-round statistically hiding commitment on NP-hardness,
then <span class=blu2> NP âŠ† coAM</span> and the polynomial hierarchy collapses. The same result holds for any
primitive that can be broken by <span class=blu2>Sam<sub>O(1)</sub></span> including collision-resistant hash functions and <span class=blu2>O(1)</span>-round 
oblivious transfer where security holds statistically for one of the parties. We also obtain
non-trivial (though weaker) consequences for <span class=blu2>k</span>-adaptive reductions for any <span class=blu2>k = poly(n)</span>.
Prior to our work, most results in this research direction either applied only to non-adaptive reductions (<span class=blu1>Bogdanov and Trevisan
[SIAM J. of Comp. '06]</span>) or to primitives with special regularity properties (<span class=blu1>Brassard [FOCS '79], Akavia et al. [FOCS '06]</span>.<br>
The main technical tool we use to prove the above is a new constant-round public-coin protocol (SampleWithSize) 
that we believe may be interesting in its own right, and that guarantees the following. Given an efficient function 
<span class=blu2>f</span> on <span class=blu2>n</span>
bits, let <span class=blu2>D</span> be the output distribution <span class=blu2>D = f(U<sub>n</sub>)</span>,
then SampleWithSize allows an efficient verifier Arthur to use an all-powerful prover Merlin's help to sample a random <span class=blu2>y â† D></span> 
along with a good multiplicative approximation of the probability <span class=blu2>p<sub>y</sub>
= Pr<sub>y' â† D</sub>[y' = y]</span>. The crucial feature of SampleWithSize
is that it extends even to distributions of the form <span class=blu2>D = f(U<sub>S</sub>)</span>,
where <span class=blu2>U<sub>S</sub></span>
is the uniform distribution on an efficiently decidable subset <span class=blu2> S âŠ†{0.1}<sup>n</sup></span>
(such <span class=blu2>D></span> are called <em>efficiently samplable with post-selection</em>), as long 
as the verifier is also given a good approximation of the value <span class=blu2>|S|</span>.</p>
</p>
</div>
</li>



<li>
<p><a name="HONRV"></a>
Iftach Haitner, Minh-Huyen Nguyen, Shien Jin Ong, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">OmercReingold</a> and <a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a><br>
<strong>Statistically Hiding Commitments and Statistical Zero-Knowledge Arguments from Any One-Way Function</strong> <br>
<span class=abslide>[abstract]</span>  <br>
SIAM Journal of Computing 2009  <a  href="http://epubs.siam.org/doi/abs/10.1137/080725404">[link]</a><br>
Draft of full version  <a href="papers/HNORV/HNORV-sicomp.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
We give a construction of statistically hiding commitment schemes (those in which the hiding property holds against even computationally unbounded adversaries) 
under the minimal complexity assumption that one-way functions exist. 
Consequently, one-way functions suffice to give statistical zero-knowledge arguments for any NP statement (whereby even a computationally 
unbounded adversarial verifier learns nothing other than the fact that the assertion being proven is true, and no polynomial-time adversarial
prover can convince the verifier of a false statement). These results resolve an open question posed by <span class=blu1> Naor et al. [J. Cryptology 98]</span>.
</p>

</div>

</li>



<li>
<p>
Iftach
Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>,
<a href="http://www.eecs.harvard.edu/%7Esalil/">Salil Vadhan</a> and  <a href="http://www.cs.berkeley.edu/%7Ehoeteck/">Hoeteck Wee</a><br>
 <b>Inaccessible Entropy</b><br>
<span class=abslide>[abstract]</span> <a href="papers/AccessibleEntropy/AccEntSemniar.pptx">[slides]</a> 
<a href="http://intractability.princeton.edu/videos/stream/videoplay.html?videofile=cs/IW2009-500kb/Iftach%20Haitner.mp4">[video (appx. 1 hour)]</a><br>
 Annual ACM Symposium on Theory of Computing (STOC), 2009  <a href="papers/AccessibleEntropy/AE-stoc.pdf">[pdf]</a><br>
</p>


<div class="box">
<p>
We put
forth a new computational notion of entropy, which measures the (in)feasibility of sampling high entropy strings that are consistent
with a given protocol. Specifically, we say that the <span class=blu1> i</span>â€™th round of a protocol <span class=blu1> (A,B)</span> has <em>accessible
entropy</em> at most <span class=blu1>k</span>, if no polynomial-time strategy <span class=blu1>A*</span> can
generate messages for <span class=blu1>A></span> such that the entropy of its message in the <span class=blu1>i</span>â€™th round has entropy
greater than <span class=blu1>k</span> when conditioned both on prior messages of the protocol and on prior coin tosses of <span class=blu1> A*</span>. 
As applications of thisnotion, we
<ul>
<li>Give a much simpler and more efficient construction of statistically hiding
commitment schemes from arbitrary one-way functions.
</li>
<li>Prove that constant-round statistically hiding
commitments are necessary for constructing constant-round zero-knowledge proof systems for NP that 
remain secure under parallel composition (assuming the existence of
one-way functions).</li>
</ul>
</p>
</div>
</li>

<li>
<p>Iftach Haitner,   <a href="http://www.eecs.harvard.edu/%7Ealon/">Alon Rosen</a> and  <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
 <b> On the (Im)Possibility of Arthur-Merlin Witness Hiding Protocols</b><br>
<span class=abslide>[abstract]</span> <a href="papers/WitnessHiding/WitnessHidingTCC.ppsx">[slides]</a>]<br>
Theory of Cryptography Conference (TCC), 2009 <a href="papers/WitnessHiding/WitnessHidingLB.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
The concept of <em>witness-hiding</em> suggested by <span class=blu1> Feige and Shamir [STOC 90]</span> is a natural relaxation of zero-knowledge. In this paper we
identify languages and distributions for which many known constant-round
public-coin protocols with negligible soundness cannot be shown to witness-hiding using
black-box techniques. In particular, our results imply that it is impossible to prove that
parallel repetition of 3-Colorability or Hamiltonicity is witness-hiding for distributions that support instances with exactly one witness, if the
proof of security is by a black-box reduction that is <em>independent</em> of the choice of the commitment scheme used in the protocol. This lower bound
conceptually matches an upper bound of Feige and Shamir that uses such a black-box reduction to show that parallel repetition of 3-Colorability
or Hamiltonicity <em>is</em> witness-hiding for distributions with ``two independent witnesses.<br>
We also consider black-box reductions for 3-Colorability or Hamiltonicity that <em>depend</em> on a specific
implementation of the commitment scheme. While we cannot rule out such reductions completely, we show that
``natural reductions" cannot bypass the limitations above.<br>
<br>
Our proofs use techniques developed by <span class=blu1>Goldreich and Krawczyk [ICALP  90]</span> for the
case of zero knowledge. The setup of witness-hiding, however, presents new technical and
conceptual difficulties that do not come up in the setup of zero-knowledge. The
high level idea is that if a black-box reduction establishes the witness-hiding
property for a protocol that is also a proof of knowledge, then this latter
property can be used ``against the reduction" to find witnesses unconditionally.
</p>
</div>
</li>


<li>
<p>
Iftach Haitner and <a href="http://research.microsoft.com/users/thomahol/">Thomas Holenstein</a><br>
<b>On the (Im)Possibility of Key Dependent Encryption</b><br>
<span class=abslide>[abstract]</span> <a href="papers/AccessibleEntropy/AccEntSemniar_f.pptx">[slides]</a> <br>
Theory of Cryptography Conference (TCC), 2009  <a href="papers/KDI/KDI-TCC_CR.pdf">[pdf]</a><br>
Draft of full version <a href="papers/KDI/KDI-full.pdf">[pdf]</a>
</p>
<div class="box"  >
<p>
We study the possibility of constructing encryption schemes secure under messages that are chosen depending on the key
<span class=blu2>k</span> of the encryption scheme itself. We give the following separation results that hold both in the private and in the public key settings:
<ul>
<li>Let <span class=blu2>H</span> be the family of <span class=blu2>poly(n)</span>-wise independent hash-functions. 
There exists no fully-black-box reduction from an encryption scheme secure against key-dependent messages to one-way permutations 
(and also to families of trapdoor permutations) if the adversary can obtain encryptions of <span class=blu2>h(k)</span> for <span class=blu2>h âˆˆ H</span>.</li>

<li>There exists no reduction from an encryption scheme secure against key-dependent messages to, essentially, <em>any</em>
cryptographic assumption, if the adversary can obtain an encryption of <span class=blu2>g(k)</span> for an <em>arbitrary</em>
g, as long as the reduction's proof of security treats both the adversary and the function <span class=blu2>g</span> as black boxes.</li>
</ul>

</div>
</li>


<li>
<p>Iftach Haitner<br>
<b>New Implications and Improved Efficiency of Constructions Based on One-way Functions</b><br>
PhD. Thesis, 2008<br>
<a href="papers/PhDThesis/FullThesis.pdf">[pdf]</a></p>
</li>

<li>
<p>Iftach Haitner<br>
<b>Semi-Honest to Malicious Oblivious Transfer -- The Black-Box Way </b><br>
<span class=abslide>[abstract]</span>  <a href="papers/SemiHonestToMalicious/SemiToMal_f.ppt">[slides]</a><br>
Theory of Cryptography Conference (TCC), 2008 <a href="papers/SemiHonestToMalicious/SemiHonestToMalicious-TCC.pdf">[pdf]</a> <br>
Full version is part of   <a href="#BBMPC"> Black-Box Constructions of Protocols for Secure Computation</a>
</p>

<div class="box"  >
<p>
Until recently, all known constructions of oblivious transfer protocols based
on general hardness assumptions had the following form. First, the hardness assumption is used in a black-box manner (i.e., the
construction uses only the input/output behavior of the primitive guaranteed by the assumption) to construct a <em>semi-honest</em>
oblivious transfer, a protocol whose security is guaranteed to hold only against adversaries that follow the prescribed protocol. Then, the
latter protocol is ``compiled" into a (malicious) oblivious transfer using non-black techniques (a Karp reduction is carried in order to
prove an NP statement in zero-knowledge). In their recent breakthrough result, <span class=blu1>Ishai, Kushilevitz, Lindel and Petrank [STOC '06] </span> deviated from
the above paradigm, presenting a black-box reduction from oblivious transfer to enhanced trapdoor permutations and to homomorphic
encryption. Here we generalize their result, presenting a black-box reduction from oblivious transfer to semi-honest oblivious transfer.
Consequently, oblivious transfer can be black-box reduced to each of the hardness assumptions known to imply a semi-honest oblivious
transfer in a black-box manner. This list currently includes beside the hardness assumptions used by Ishai et al. also the existence of
families of dense trapdoor permutations and of non trivial single-server private information retrieval. 
</p>
</div>
</li>


<li>
<p>
Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a> and&nbsp; <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<b>A Linear Lower Bound on the Communication Complexity of Single-Server Private Information Retrieval</b><br>
<span class=abslide>[abstract]</span>  <a href="papers/PIRLowerBound/PIRLowerBound.ppt">[slides]</a> <br>
Theory of Cryptography Conference (TCC), 2008 <a href="papers/PIRLowerBound/PIRLowerBound.pdf">[pdf]</a><br>
Full version is part of  <a href="#HHRSJoint">Finding Collisions in Interactive Protocols â€” Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>
</p>
<div class="box"  >
<p>
We  study the communication complexity of single-server Private Information Retrieval (PIR) protocols that are based on fundamental cryptographic
primitives in a black-box manner. In this setting, we establish a tight lower bound on the number of bits communicated by the server in any
polynomially-preserving construction that relies on trapdoor permutations. More specifically, our main result states that in such
constructions <span class=blu2>Î©(n)</span> bits must be communicated by the server, where <span class=blu2>n</span>
is the size of the server's database, and this improves the <span class=blu2>Î©(n / log n)</span> lower bound due to
<span class=blu1> Haitner, Hoch, Reingold and Segev [FOCS '07]</span>. Therefore, in the setting under consideration, the naive solution in which the user downloads the
entire database turns out to be optimal up to constant multiplicative factors. We note that the lower bound we establish holds for the most
generic form of trapdoor permutations, including in particular enhanced trapdoor permutations.<br>
Technically speaking, this paper consists of two main contributions from which our lower bound is obtained. First, we derive a tight lower
bound on the number of bits communicated by the sender during the commit stage of any black-box construction of a statistically-hiding
bit-commitment scheme from a family of trapdoor permutations. This lower bound asymptotically matches the upper bound provided by the
scheme of <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO '92]</span>. Second, we improve the efficiency of the reduction of statistically-hiding
commitment schemes to low-communication single-server PIR, due to <span class=blu1>Beimel, Ishai, Kushilevitz and Malkin [STOC '99]</span>. In particular, we
present a reduction that essentially preserves the communication complexity of the underlying single-server PIR protocol. 
</p>
</div>
</li>


<li>
<p>Iftach Haitner, <a href="http://www.wisdom.weizmann.ac.il/%7Eyaakovh">Jonathan J. Hoch</a>, <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold">Omer Reingold</a>
and <a href="http://www.wisdom.weizmann.ac.il/%7Egils/">Gil Segev</a><br>
<b>Finding Collisions in Interactive Protocols -- A Tight Lower Bound on the Round Complexity of Statistically-Hiding Commitments</b><br>
<span class=abslide>[abstract]</span> <a href="papers/FindingCollisions/FindingCollisions.pps">[slides]</a><br>
IEEE Symposium on Foundations of Computer Science (FOCS), 2007 <a href="papers/FindingCollisions/FindingCollisions-FOCS.pdf">[pdf]</a><br>
Full version is part of  <a href="#HHRSJoint">Finding Collisions in Interactive Protocols â€” Tight Lower Bounds on the Round Complexity and
Communication Complexity of Statistically Hiding Commitments</a>
</p>

<div class="box"  >
<p>
We study the round complexity of various cryptographic protocols. Our main result is a tight lower bound on
the round complexity of any fully-black-box construction of a statistically-hiding commitment scheme from one-
way permutations, and even from trapdoor permutations. This lower bound matches the round complexity of the
statistically-hiding commitment scheme due to <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO â€™92]</span>. 
As a corollary, we derive similar tight lower bounds for several other cryptographic protocols, such as single-server private infor-
mation retrieval, interactive hashing, and oblivious transfer that guarantees statistical security for one of the parties.<br>

Our techniques extend the collision-finding oracle due to <span class=blu1>Simon [EUROCRYPT â€™98]</span> to the setting of interactive protocols 
(our extension also implies an alternative proof for the main property of the original oracle). In addition, we substantially extend the reconstruction paradigm of 
<span class=blu1> Gennaro and Trevisan (FOCS â€™00]</span>. In both cases, our extensions are quite delicate and may be found useful in proving
additional black-box separation results.
</p>
</div>

</li>

<li>
<p>Iftach Haitner and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>Statistically Hiding Commitment from Any One-Way Function </b><br>
<span class=abslide>[abstract]</span> <a href="papers/SCfromOWF/SCfromOWF.pps">[slides]</a><br>
Annual ACM Symposium on Theory of Computing (STOC), 2007 <a href="papers/SCfromOWF/SCfromOWF-STOC.pdf">[pdf]</a>
Full version is part of <a href="#HONRV">Statistically Hiding Commitments and Statistical Zero-Knowledge Arguments from Any One-Way Function</a>
</p>
<div class="box" >
<p>
We give a construction of statistically-hiding commitment schemes (ones where the hiding property holds information theoretically), based on
the minimal cryptographic assumption that one-way functions exist. Our construction employs two-phase commitment schemes, recently constructed
by <span class=blu1>Nguyen, Ong and Vadhan [FOCS `06]</span>, and universal one-way hash functions introduced and constructed by <span class=blu1>Naor and Yung [STOC `89]</span> and
<span class=blu1>Rompel [STOC `90]</span>. 
</div>
</li>

<li>
<p>Iftach Haitner and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>A New Interactive Hashing Theorem </b><br>
<span class=abslide>[abstract]</span> <a href="papers/IneractiveHashing/IHSeminar_F.ppt">[slides]</a><br>

Journal of Cryptology 2014 <a  href="http://link.springer.com/article/10.1007/s00145-012-9139-0">[link]</a><br>
IEEE Conference on Computational Complexity(CCC), 2007 <a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[pdf]</a><br>
Draft of full version  <a  href="papers/IneractiveHashing/IneractiveHashing_Jour.pdf">[pdf]</a>
</p>
<div class="box" >
<p>
Interactive hashing, introduced by <span class=blu1>Naor, Ostrovsky, Venkatesan and Yung [CRYPTO '92]</span>,
plays an important role in many cryptographic protocols. In particular, interactive hashing is a major component in all known constructions
(which are based on general one-way permutations and one-way functions) of statistically hiding commitment schemes and of statistical
zero-knowledge arguments. Interactive hashing with respect to a one-way permutation <span class=blu2>f</span>, is a
two-party protocol that enables a sender that knows <span class=blu2>y=f(x)</span> to transfer a random hash
<span class=blu2>z=h(y)</span> to a receiver. The receiver is guaranteed that the sender is committed to <span class=blu2>y</span> (in the sense that it cannot
come up with <span class=blu2>x</span> and <span class=blu2>x'</span> such that <span class=blu2>f(x) â‰  f(x')</span>, but <span class=blu2>h(f(x))=h(f(x'))=z</span>). The sender
is guaranteed that the receiver does not learn any additional information on <span class=blu2>y</span>. In particular, when <span class=blu2>h</span>  is a two-to-one hash
function, the receiver does not learn which of the two preimages <span class=blu2>{y,y'}=h<sup>-1</sup>(z)</span>
 is the one the sender can invert with respect to <span class=blu2>f</span>.<br>
 
This paper reexamines the notion of interactive hashing. We give an alternative proof for the Naor et al. protocol, which seems
significantly simpler and more intuitive than the original one. Moreover, the new proof achieves much better parameters (in terms of
how security preserving the reduction is). Finally, by applying our new proof to a close variant of the Naor et al. protocol, we achieve a more
versatile interactive hashing theorem for a more general setting than that of the Naor et al. protocol.
</p> 
</div>
</li>


<li>
<p><a name="RandIt">
Iftach Haitner,   <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>, and </a>Omer Reingold<br>
<b>On the Power of the Randomized Iterate</b> <br>
<span class=abslide>[abstract]</span> <a href="papers/RandomizedIteate/Randomized_Iterate.pps">[slides]</a><br>
SIAM Journal of Computing 2011   <a  href="http://epubs.siam.org/doi/abs/10.1137/080721820">[link]</a><br>
Advanced in Cryptology - CRYPTO, 2006 <a href="papers/RandomizedIteate/Randomized_Iterate_CryptoCR.pdf">[pdf]</a><br>
Draft of full version  <a href="papers/RandomizedIteate/RandomIterate.pdf">[pdf]</a>
</p>

<div class="box">
<p>
We consider two of the most fundamental theorems in Cryptography. The first, due to <span class=blu1> HÃ¥stad, Impagliazzo, Levin and Luby [STOC '89, STOC '90,
SIAM J. on Computing '99]</span>, is that pseudorandom generators can be constructed from any one-way function. The second, due to <span class=blu1> Yao [FOCS
'82]</span>, states that the existence of weak one-way functions implies the
existence of full fledged one-way functions. These powerful plausibility results shape our understanding of hardness and randomness
in Cryptography, but unfortunately their proofs are not as tight (i.e., security preserving) as one may desire.<br>
This work revisits a technique that we call the <i>randomized
iterate</i>, introduced by <span class=blu1>Goldreich, Krawczyk and Luby [SIAM J.
on Computing '93]</span>. This technique was used by Goldreich et al. to give a construction of pseudorandom generators from regular one-way
functions. We simplify and strengthen this technique in order to obtain a similar construction where the seed length of the resulting
generators is as short as <span class=blu2>Î˜(n log n)</span> rather than <span class=blu2>Î˜(n<sup>3</sup>)</span>
achieved by Goldreich et al. Our technique has the potential of implying seed-length <span class=blu2>Î˜(n)</span>,
and the only bottleneck for such a result is the parameters of current generators against space bounded computations. We give a construction
with similar parameters for security amplification of regular one-way functions. This improves upon the construction of Goldreich,
<span class=blu1>Impagliazzo, Levin, Venkatesan and Zuckerman [FOCS '90]</span> in that the
construction does not need to ``know" the regularity parameter of the functions (in terms of security, the two reductions are incomparable).
In addition, we use the randomized iterate to show a construction of a pseudorandom generator based on an exponentially hard one-way function
that has seed length of only <span class=blu2>Î˜(n<sup>2</sup>)</span>. This improves a recent result of <span class=blu1>Holenstein [TCC '06]</span> that shows a
construction with seed length </p>Î˜(n<sup>5</sup>)</span> based on such one-way functions. Finally, we show that the randomized
iterate may even be useful in the general context of HÃ¥stad et al. In particular, we use the randomized iterate to replace the basic building
block of the HÃ¥stad et al. construction. Interestingly, this modification improves efficiency by an <span class=blu2>n<sup>3</sup></span>
factor and reduces the seed length to <span class=blu2>Î˜(n<sup>7</sup>)</span> (which also implies improvement in the security of the construction). 
</p>
</div>
</li>

<li>
<p>Iftach Haitner,  <a href="http://www.wisdom.weizmann.ac.il/%7Eharnik/"> Danny Harnik</a>
and  <a href="http://www.wisdom.weizmann.ac.il/%7Ereingold/"> Omer Reingold</a><br>
<b>On Efficient Pseudorandom Generators from Exponentially Hard One-Way Functions</b><br>
<span class=abslide>[abstract]</span> <a href="papers/RandomizedIteate/PrgFromHard.pps">[slides]</a><br>
International Colloquium on Automata, Languages and Programming - ICALP, 2006  <a href="papers/RandomizedIteate/PrgFromHard-ICALP.pdf">[pdf]</a><br>
Full version is part of <a href="#RandIt">On the Power of the Randomized Iterate</a>
</p>
<div class="box"  >
<p>
We show a construction of a pseudorandom generator from any exponentially
hard one-way function with a blowup of only <span class=blu2>Î˜(n<sup>2</sup>)</span>.
This Improves the recent <span class=blu2> Î˜(n<sup>5</sup>)</span> construction of <span class=blu1>Holenstein [TCC '06]</span>. 
Our technique uses the tools recently presented in <span class=blu1>Haitner et al. [Crypto '06]</span> for the setting of regular one-way
functions, and further develops them. 
</p>
</div>
</li>


<li>
<p>Iftach Haitner, Omer Horvitz, <a href="http://www.cs.umd.edu/%7Ejkatz/">Jonathan Katz</a>, Chiu-Yuen Koo, Ruggero Morselli and <a href="http://www.cs.haifa.ac.il/%7Eronen/">Ronen Shaltiel</a><br>
<b>Reducing Complexity Assumptions for Statistically-Hiding Commitment </b><br>
<span class=abslide>[abstract]</span> <a href="papers/SCfromRegularOWF/SCfromRegularOWF.pps">[slides]</a><br>
Journal of Cryptology 2009 <a  href="http://link.springer.com/content/pdf/10.1007/s00145-007-9012-8">[link]</a><br>
Advances in Cryptology - Eurocrypt, 2005  <a href="papers/SCfromRegularOWF/SCfromRegularOWF-eurocrypt.pdf">[pdf]</a><br>
Draft of full version  <a href="papers/SCfromRegularOWF/SCfromRegularOWF.pdf">[pdf]</a>
</p>
<div class="box"  >
<p>
We revisit the following question: <em>what are the minimal
assumptions needed to construct statistically-hiding commitment schemes</em>?
<span class=blu1> Naor et al. [J. Cryptology 98]</span> show how to construct such schemes based on any one-way
permutation. We improve upon this by showing a construction based on any approximable preimage-size one-way function.
These are one-way functions for which it is possible to efficiently approximate the number of pre-images of a given output. A special case
is the class of <em>regular</em> one-way functions where all points in the image of the function have the same (known) number of
pre-images.<br>

We also prove two additional results related to statistically hiding commitment. First, we prove a (folklore) <em parallel composition theorem></em> 
showing, roughly speaking, that the statistical hiding property of any such commitment scheme is amplified exponentially when multiple independent parallel
executions of the scheme are carried out. Second, we show a <em>compiler</em> which transforms any commitment scheme which is statistically hiding
against an honest-but-curious receiver into one which is statistically hiding even against a malicious receiver.
</p>
</div>
</li>

<li>
<p>Iftach Haitner<b><br>
Implementing Oblivious Transfer Using a Collection of Dense Trapdoor Permutations</b><br>
<span class=abslide>[abstract]</span> <a href="papers/OTDenseTDP/OTDenseTDP.pps">[slides]</a><br>
Theory of Cryptography Conference (TCC), 2004  <a href="papers/OTDenseTDP/OT_Dense_TCC.pdf">[pdf]</a> <br>
Draft of full version <a href="papers/OTDenseTDP/OTDenseTDP.pdf">[pdf]</a>
</p>

<div class="box"  >
<p>
Until recently, the existence of collection of trapdoor permutations (TDP) was believed (and claimed) to imply almost all of the
major cryptographic primitives, including public-key encryption (PKE), oblivious transfer (OT), and non-interactive zero-knowledge (NIZK). It
was recently realized, however, that the commonly accepted general definition of TDP needs to be strengthened slightly in order to make the
security proofs of TDP-based OT go through. We present an implementation of oblivious transfer based on collection of dense trapdoor permutations. 
The latter is a collection of trapdoor permutations, with the property that the permutation domains are polynomially dense in the
set of all strings of a particular length. Previous TDP-based implemen tations of oblivious transfer assumed an enhancement of the hardness
assumption (of the collection). <br>

Here we present an alternative construction that only requires the TDP to have <em>dense</em> domains. Specically we present
an implementation of OT based on any dense TDP.
</p>
</div>

</li>
</ul>
</div> <!------------end wrapper----------------------->


<p align="justify"><!-- Start of StatCounter Code -->
</p>
<p align="justify"> </p>
</div> <!--wrapall-->


</body></html>